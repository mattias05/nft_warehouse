import * as neverthrow from 'neverthrow';
import { ResultAsync, Result } from 'neverthrow';
import * as rxjs from 'rxjs';
import { Subject, Observable, ReplaySubject, BehaviorSubject } from 'rxjs';
import * as radix_connect_common from 'radix-connect-common';
import { RadixButtonStatus, RadixButtonTheme, RequestItem, Account as Account$1, RequestStatusTypes } from 'radix-connect-common';
import * as valibot from 'valibot';
import { Output, ValiError } from 'valibot';
import { Logger as Logger$1 } from 'tslog';
import { Buffer } from 'buffer';

/**
 * Wallet schemas
 */
type Account = Output<typeof Account>;
declare const Account: valibot.ObjectSchema<{
    address: valibot.StringSchema<string>;
    label: valibot.StringSchema<string>;
    appearanceId: valibot.NumberSchema<number>;
}, undefined, {
    address: string;
    label: string;
    appearanceId: number;
}>;
type Proof = Output<typeof Proof>;
declare const Proof: valibot.ObjectSchema<{
    publicKey: valibot.StringSchema<string>;
    signature: valibot.StringSchema<string>;
    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
}, undefined, {
    publicKey: string;
    signature: string;
    curve: "curve25519" | "secp256k1";
}>;
type AccountProof = Output<typeof AccountProof>;
declare const AccountProof: valibot.ObjectSchema<{
    accountAddress: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
}, undefined, {
    accountAddress: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
}>;
type Persona = Output<typeof Persona>;
declare const Persona: valibot.ObjectSchema<{
    identityAddress: valibot.StringSchema<string>;
    label: valibot.StringSchema<string>;
}, undefined, {
    label: string;
    identityAddress: string;
}>;
declare const personaDataFullNameVariant: {
    readonly western: "western";
    readonly eastern: "eastern";
};
type PersonaDataNameVariant = Output<typeof PersonaDataNameVariant>;
declare const PersonaDataNameVariant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
type PersonaDataName = Output<typeof PersonaDataName>;
declare const PersonaDataName: valibot.ObjectSchema<{
    variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
    familyName: valibot.StringSchema<string>;
    nickname: valibot.StringSchema<string>;
    givenNames: valibot.StringSchema<string>;
}, undefined, {
    variant: "western" | "eastern";
    familyName: string;
    nickname: string;
    givenNames: string;
}>;
type NumberOfValues = Output<typeof NumberOfValues>;
declare const NumberOfValues: valibot.ObjectSchema<{
    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
    quantity: valibot.NumberSchema<number>;
}, undefined, {
    quantifier: "exactly" | "atLeast";
    quantity: number;
}>;
type AccountsRequestItem = Output<typeof AccountsRequestItem>;
declare const AccountsRequestItem: valibot.ObjectSchema<{
    challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
    numberOfAccounts: valibot.ObjectSchema<{
        quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
        quantity: valibot.NumberSchema<number>;
    }, undefined, {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    }>;
}, undefined, {
    numberOfAccounts: {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    };
    challenge?: string | undefined;
}>;
type AccountsRequestResponseItem = Output<typeof AccountsRequestResponseItem>;
declare const AccountsRequestResponseItem: valibot.ObjectSchema<{
    accounts: valibot.ArraySchema<valibot.ObjectSchema<{
        address: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
        appearanceId: valibot.NumberSchema<number>;
    }, undefined, {
        address: string;
        label: string;
        appearanceId: number;
    }>, {
        address: string;
        label: string;
        appearanceId: number;
    }[]>;
    challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
    proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
        accountAddress: valibot.StringSchema<string>;
        proof: valibot.ObjectSchema<{
            publicKey: valibot.StringSchema<string>;
            signature: valibot.StringSchema<string>;
            curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
        }, undefined, {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        }>;
    }, undefined, {
        accountAddress: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
    }>, {
        accountAddress: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
    }[]>, undefined, {
        accountAddress: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
    }[] | undefined>;
}, undefined, {
    accounts: {
        address: string;
        label: string;
        appearanceId: number;
    }[];
    challenge?: string | undefined;
    proofs?: {
        accountAddress: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
    }[] | undefined;
}>;
type PersonaDataRequestItem = Output<typeof PersonaDataRequestItem>;
declare const PersonaDataRequestItem: valibot.ObjectSchema<{
    isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
    numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
        quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
        quantity: valibot.NumberSchema<number>;
    }, undefined, {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    }>, undefined, {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    } | undefined>;
    numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
        quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
        quantity: valibot.NumberSchema<number>;
    }, undefined, {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    }>, undefined, {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    } | undefined>;
}, undefined, {
    isRequestingName?: boolean | undefined;
    numberOfRequestedEmailAddresses?: {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    } | undefined;
    numberOfRequestedPhoneNumbers?: {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    } | undefined;
}>;
type PersonaDataRequestResponseItem = Output<typeof PersonaDataRequestResponseItem>;
declare const PersonaDataRequestResponseItem: valibot.ObjectSchema<{
    name: valibot.OptionalSchema<valibot.ObjectSchema<{
        variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
        familyName: valibot.StringSchema<string>;
        nickname: valibot.StringSchema<string>;
        givenNames: valibot.StringSchema<string>;
    }, undefined, {
        variant: "western" | "eastern";
        familyName: string;
        nickname: string;
        givenNames: string;
    }>, undefined, {
        variant: "western" | "eastern";
        familyName: string;
        nickname: string;
        givenNames: string;
    } | undefined>;
    emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
}, undefined, {
    name?: {
        variant: "western" | "eastern";
        familyName: string;
        nickname: string;
        givenNames: string;
    } | undefined;
    emailAddresses?: string[] | undefined;
    phoneNumbers?: string[] | undefined;
}>;
type ResetRequestItem = Output<typeof ResetRequestItem>;
declare const ResetRequestItem: valibot.ObjectSchema<{
    accounts: valibot.BooleanSchema<boolean>;
    personaData: valibot.BooleanSchema<boolean>;
}, undefined, {
    accounts: boolean;
    personaData: boolean;
}>;
type LoginRequestResponseItem = Output<typeof LoginRequestResponseItem>;
declare const LoginRequestResponseItem: valibot.ObjectSchema<{
    persona: valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>;
    challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
    proof: valibot.OptionalSchema<valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    } | undefined>;
}, undefined, {
    persona: {
        label: string;
        identityAddress: string;
    };
    proof?: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    } | undefined;
    challenge?: string | undefined;
}>;
type WalletUnauthorizedRequestItems = Output<typeof WalletUnauthorizedRequestItems>;
declare const WalletUnauthorizedRequestItems: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}>;
type AuthUsePersonaRequestItem = Output<typeof AuthUsePersonaRequestItem>;
declare const AuthUsePersonaRequestItem: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
    identityAddress: valibot.StringSchema<string>;
}, undefined, {
    identityAddress: string;
    discriminator: "usePersona";
}>;
type AuthLoginWithoutChallengeRequestItem = Output<typeof AuthLoginWithoutChallengeRequestItem>;
declare const AuthLoginWithoutChallengeRequestItem: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
}, undefined, {
    discriminator: "loginWithoutChallenge";
}>;
type AuthLoginWithChallengeRequestItem = Output<typeof AuthLoginWithChallengeRequestItem>;
declare const AuthLoginWithChallengeRequestItem: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
    challenge: valibot.StringSchema<string>;
}, undefined, {
    challenge: string;
    discriminator: "loginWithChallenge";
}>;
declare const AuthLoginRequestItem: valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
}, undefined, {
    discriminator: "loginWithoutChallenge";
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
    challenge: valibot.StringSchema<string>;
}, undefined, {
    challenge: string;
    discriminator: "loginWithChallenge";
}>)[], {
    discriminator: "loginWithoutChallenge";
} | {
    challenge: string;
    discriminator: "loginWithChallenge";
}>;
declare const AuthRequestItem: valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
    identityAddress: valibot.StringSchema<string>;
}, undefined, {
    identityAddress: string;
    discriminator: "usePersona";
}> | valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
}, undefined, {
    discriminator: "loginWithoutChallenge";
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
    challenge: valibot.StringSchema<string>;
}, undefined, {
    challenge: string;
    discriminator: "loginWithChallenge";
}>)[], {
    discriminator: "loginWithoutChallenge";
} | {
    challenge: string;
    discriminator: "loginWithChallenge";
}>)[], {
    identityAddress: string;
    discriminator: "usePersona";
} | {
    discriminator: "loginWithoutChallenge";
} | {
    challenge: string;
    discriminator: "loginWithChallenge";
}>;
type WalletAuthorizedRequestItems = Output<typeof WalletAuthorizedRequestItems>;
declare const WalletAuthorizedRequestItems: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
    auth: valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
        identityAddress: valibot.StringSchema<string>;
    }, undefined, {
        identityAddress: string;
        discriminator: "usePersona";
    }> | valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
    }, undefined, {
        discriminator: "loginWithoutChallenge";
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
        challenge: valibot.StringSchema<string>;
    }, undefined, {
        challenge: string;
        discriminator: "loginWithChallenge";
    }>)[], {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    }>)[], {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    }>;
    reset: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.BooleanSchema<boolean>;
        personaData: valibot.BooleanSchema<boolean>;
    }, undefined, {
        accounts: boolean;
        personaData: boolean;
    }>, undefined, {
        accounts: boolean;
        personaData: boolean;
    } | undefined>;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined>;
    ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
    ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "authorizedRequest";
    auth: {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    };
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
    reset?: {
        accounts: boolean;
        personaData: boolean;
    } | undefined;
    ongoingAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    ongoingPersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}>;
type WalletRequestItems = Output<typeof WalletRequestItems>;
declare const WalletRequestItems: valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
    auth: valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
        identityAddress: valibot.StringSchema<string>;
    }, undefined, {
        identityAddress: string;
        discriminator: "usePersona";
    }> | valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
    }, undefined, {
        discriminator: "loginWithoutChallenge";
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
        challenge: valibot.StringSchema<string>;
    }, undefined, {
        challenge: string;
        discriminator: "loginWithChallenge";
    }>)[], {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    }>)[], {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    }>;
    reset: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.BooleanSchema<boolean>;
        personaData: valibot.BooleanSchema<boolean>;
    }, undefined, {
        accounts: boolean;
        personaData: boolean;
    }>, undefined, {
        accounts: boolean;
        personaData: boolean;
    } | undefined>;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined>;
    ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
    ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "authorizedRequest";
    auth: {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    };
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
    reset?: {
        accounts: boolean;
        personaData: boolean;
    } | undefined;
    ongoingAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    ongoingPersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}>)[], {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
} | {
    discriminator: "authorizedRequest";
    auth: {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    };
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
    reset?: {
        accounts: boolean;
        personaData: boolean;
    } | undefined;
    ongoingAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    ongoingPersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}>;
type SendTransactionItem = Output<typeof SendTransactionItem>;
declare const SendTransactionItem: valibot.ObjectSchema<{
    transactionManifest: valibot.StringSchema<string>;
    version: valibot.NumberSchema<number>;
    blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    message: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
}, undefined, {
    transactionManifest: string;
    version: number;
    message?: string | undefined;
    blobs?: string[] | undefined;
}>;
type WalletTransactionItems = Output<typeof WalletTransactionItems>;
declare const WalletTransactionItems: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"transaction", "transaction">;
    send: valibot.ObjectSchema<{
        transactionManifest: valibot.StringSchema<string>;
        version: valibot.NumberSchema<number>;
        blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        message: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
    }, undefined, {
        transactionManifest: string;
        version: number;
        message?: string | undefined;
        blobs?: string[] | undefined;
    }>;
}, undefined, {
    discriminator: "transaction";
    send: {
        transactionManifest: string;
        version: number;
        message?: string | undefined;
        blobs?: string[] | undefined;
    };
}>;
type SendTransactionResponseItem = Output<typeof SendTransactionResponseItem>;
declare const SendTransactionResponseItem: valibot.ObjectSchema<{
    transactionIntentHash: valibot.StringSchema<string>;
}, undefined, {
    transactionIntentHash: string;
}>;
type WalletTransactionResponseItems = Output<typeof WalletTransactionResponseItems>;
declare const WalletTransactionResponseItems: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"transaction", "transaction">;
    send: valibot.ObjectSchema<{
        transactionIntentHash: valibot.StringSchema<string>;
    }, undefined, {
        transactionIntentHash: string;
    }>;
}, undefined, {
    discriminator: "transaction";
    send: {
        transactionIntentHash: string;
    };
}>;
type CancelRequest = Output<typeof CancelRequest>;
declare const CancelRequest: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"cancelRequest", "cancelRequest">;
}, undefined, {
    discriminator: "cancelRequest";
}>;
type WalletInteractionItems = Output<typeof WalletInteractionItems>;
declare const WalletInteractionItems: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
    auth: valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
        identityAddress: valibot.StringSchema<string>;
    }, undefined, {
        identityAddress: string;
        discriminator: "usePersona";
    }> | valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
    }, undefined, {
        discriminator: "loginWithoutChallenge";
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
        challenge: valibot.StringSchema<string>;
    }, undefined, {
        challenge: string;
        discriminator: "loginWithChallenge";
    }>)[], {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    }>)[], {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    }>;
    reset: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.BooleanSchema<boolean>;
        personaData: valibot.BooleanSchema<boolean>;
    }, undefined, {
        accounts: boolean;
        personaData: boolean;
    }>, undefined, {
        accounts: boolean;
        personaData: boolean;
    } | undefined>;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined>;
    ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
    ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "authorizedRequest";
    auth: {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    };
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
    reset?: {
        accounts: boolean;
        personaData: boolean;
    } | undefined;
    ongoingAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    ongoingPersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}>)[], {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
} | {
    discriminator: "authorizedRequest";
    auth: {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    };
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
    reset?: {
        accounts: boolean;
        personaData: boolean;
    } | undefined;
    ongoingAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    ongoingPersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"transaction", "transaction">;
    send: valibot.ObjectSchema<{
        transactionManifest: valibot.StringSchema<string>;
        version: valibot.NumberSchema<number>;
        blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        message: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
    }, undefined, {
        transactionManifest: string;
        version: number;
        message?: string | undefined;
        blobs?: string[] | undefined;
    }>;
}, undefined, {
    discriminator: "transaction";
    send: {
        transactionManifest: string;
        version: number;
        message?: string | undefined;
        blobs?: string[] | undefined;
    };
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"cancelRequest", "cancelRequest">;
}, undefined, {
    discriminator: "cancelRequest";
}>)[], {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
} | {
    discriminator: "authorizedRequest";
    auth: {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    };
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
    reset?: {
        accounts: boolean;
        personaData: boolean;
    } | undefined;
    ongoingAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    ongoingPersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
} | {
    discriminator: "transaction";
    send: {
        transactionManifest: string;
        version: number;
        message?: string | undefined;
        blobs?: string[] | undefined;
    };
} | {
    discriminator: "cancelRequest";
}>;
type Metadata = Output<typeof Metadata>;
declare const Metadata: valibot.ObjectSchema<{
    version: valibot.LiteralSchema<2, 2>;
    networkId: valibot.NumberSchema<number>;
    dAppDefinitionAddress: valibot.StringSchema<string>;
    origin: valibot.StringSchema<string>;
}, undefined, {
    version: 2;
    networkId: number;
    dAppDefinitionAddress: string;
    origin: string;
}>;
type WalletInteraction = Output<typeof WalletInteraction>;
declare const WalletInteraction: valibot.ObjectSchema<{
    interactionId: valibot.StringSchema<string>;
    metadata: valibot.ObjectSchema<{
        version: valibot.LiteralSchema<2, 2>;
        networkId: valibot.NumberSchema<number>;
        dAppDefinitionAddress: valibot.StringSchema<string>;
        origin: valibot.StringSchema<string>;
    }, undefined, {
        version: 2;
        networkId: number;
        dAppDefinitionAddress: string;
        origin: string;
    }>;
    items: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
        oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            numberOfAccounts: valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>;
        }, undefined, {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        }>, undefined, {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined>;
        oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
            numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined>;
            numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined>;
        }, undefined, {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        }>, undefined, {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined>;
    }, undefined, {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        oneTimePersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
        auth: valibot.UnionSchema<(valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
            identityAddress: valibot.StringSchema<string>;
        }, undefined, {
            identityAddress: string;
            discriminator: "usePersona";
        }> | valibot.UnionSchema<(valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
        }, undefined, {
            discriminator: "loginWithoutChallenge";
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
            challenge: valibot.StringSchema<string>;
        }, undefined, {
            challenge: string;
            discriminator: "loginWithChallenge";
        }>)[], {
            discriminator: "loginWithoutChallenge";
        } | {
            challenge: string;
            discriminator: "loginWithChallenge";
        }>)[], {
            identityAddress: string;
            discriminator: "usePersona";
        } | {
            discriminator: "loginWithoutChallenge";
        } | {
            challenge: string;
            discriminator: "loginWithChallenge";
        }>;
        reset: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.BooleanSchema<boolean>;
            personaData: valibot.BooleanSchema<boolean>;
        }, undefined, {
            accounts: boolean;
            personaData: boolean;
        }>, undefined, {
            accounts: boolean;
            personaData: boolean;
        } | undefined>;
        oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            numberOfAccounts: valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>;
        }, undefined, {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        }>, undefined, {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined>;
        ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            numberOfAccounts: valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>;
        }, undefined, {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        }>, undefined, {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined>;
        oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
            numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined>;
            numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined>;
        }, undefined, {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        }>, undefined, {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined>;
        ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
            numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined>;
            numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined>;
        }, undefined, {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        }>, undefined, {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined>;
    }, undefined, {
        discriminator: "authorizedRequest";
        auth: {
            identityAddress: string;
            discriminator: "usePersona";
        } | {
            discriminator: "loginWithoutChallenge";
        } | {
            challenge: string;
            discriminator: "loginWithChallenge";
        };
        oneTimeAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        oneTimePersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
        reset?: {
            accounts: boolean;
            personaData: boolean;
        } | undefined;
        ongoingAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        ongoingPersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    }>)[], {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        oneTimePersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            identityAddress: string;
            discriminator: "usePersona";
        } | {
            discriminator: "loginWithoutChallenge";
        } | {
            challenge: string;
            discriminator: "loginWithChallenge";
        };
        oneTimeAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        oneTimePersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
        reset?: {
            accounts: boolean;
            personaData: boolean;
        } | undefined;
        ongoingAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        ongoingPersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"transaction", "transaction">;
        send: valibot.ObjectSchema<{
            transactionManifest: valibot.StringSchema<string>;
            version: valibot.NumberSchema<number>;
            blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            message: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        }, undefined, {
            transactionManifest: string;
            version: number;
            message?: string | undefined;
            blobs?: string[] | undefined;
        }>;
    }, undefined, {
        discriminator: "transaction";
        send: {
            transactionManifest: string;
            version: number;
            message?: string | undefined;
            blobs?: string[] | undefined;
        };
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"cancelRequest", "cancelRequest">;
    }, undefined, {
        discriminator: "cancelRequest";
    }>)[], {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        oneTimePersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            identityAddress: string;
            discriminator: "usePersona";
        } | {
            discriminator: "loginWithoutChallenge";
        } | {
            challenge: string;
            discriminator: "loginWithChallenge";
        };
        oneTimeAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        oneTimePersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
        reset?: {
            accounts: boolean;
            personaData: boolean;
        } | undefined;
        ongoingAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        ongoingPersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    } | {
        discriminator: "transaction";
        send: {
            transactionManifest: string;
            version: number;
            message?: string | undefined;
            blobs?: string[] | undefined;
        };
    } | {
        discriminator: "cancelRequest";
    }>;
}, undefined, {
    interactionId: string;
    metadata: {
        version: 2;
        networkId: number;
        dAppDefinitionAddress: string;
        origin: string;
    };
    items: {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        oneTimePersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            identityAddress: string;
            discriminator: "usePersona";
        } | {
            discriminator: "loginWithoutChallenge";
        } | {
            challenge: string;
            discriminator: "loginWithChallenge";
        };
        oneTimeAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        oneTimePersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
        reset?: {
            accounts: boolean;
            personaData: boolean;
        } | undefined;
        ongoingAccounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            challenge?: string | undefined;
        } | undefined;
        ongoingPersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    } | {
        discriminator: "transaction";
        send: {
            transactionManifest: string;
            version: number;
            message?: string | undefined;
            blobs?: string[] | undefined;
        };
    } | {
        discriminator: "cancelRequest";
    };
}>;
type WalletUnauthorizedRequestResponseItems = Output<typeof WalletUnauthorizedRequestResponseItems>;
declare const WalletUnauthorizedRequestResponseItems: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            accountAddress: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }>, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[]>, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    }>, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        name: valibot.OptionalSchema<valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    }, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    }>, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
}>;
type AuthLoginWithoutChallengeRequestResponseItem = Output<typeof AuthLoginWithoutChallengeRequestResponseItem>;
declare const AuthLoginWithoutChallengeRequestResponseItem: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
    persona: valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>;
}, undefined, {
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithoutChallenge";
}>;
type AuthLoginWithChallengeRequestResponseItem = Output<typeof AuthLoginWithChallengeRequestResponseItem>;
declare const AuthLoginWithChallengeRequestResponseItem: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
    persona: valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>;
    challenge: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
}, undefined, {
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithChallenge";
}>;
declare const AuthLoginRequestResponseItem: valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
    persona: valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>;
}, undefined, {
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithoutChallenge";
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
    persona: valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>;
    challenge: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
}, undefined, {
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithChallenge";
}>)[], {
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithoutChallenge";
} | {
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithChallenge";
}>;
type AuthUsePersonaRequestResponseItem = Output<typeof AuthUsePersonaRequestResponseItem>;
declare const AuthUsePersonaRequestResponseItem: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
    persona: valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>;
}, undefined, {
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "usePersona";
}>;
type AuthRequestResponseItem = Output<typeof AuthRequestResponseItem>;
declare const AuthRequestResponseItem: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
    persona: valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>;
}, undefined, {
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithoutChallenge";
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
    persona: valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>;
    challenge: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
}, undefined, {
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithChallenge";
}>)[], {
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithoutChallenge";
} | {
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithChallenge";
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
    persona: valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>;
}, undefined, {
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "usePersona";
}>)[], {
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithoutChallenge";
} | {
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "loginWithChallenge";
} | {
    persona: {
        label: string;
        identityAddress: string;
    };
    discriminator: "usePersona";
}>;
type WalletAuthorizedRequestResponseItems = Output<typeof WalletAuthorizedRequestResponseItems>;
declare const WalletAuthorizedRequestResponseItems: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
    auth: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
        persona: valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>;
    }, undefined, {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
        persona: valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>;
        challenge: valibot.StringSchema<string>;
        proof: valibot.ObjectSchema<{
            publicKey: valibot.StringSchema<string>;
            signature: valibot.StringSchema<string>;
            curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
        }, undefined, {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        }>;
    }, undefined, {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    }>)[], {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
        persona: valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>;
    }, undefined, {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    }>)[], {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    } | {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    }>;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            accountAddress: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }>, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[]>, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    }>, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined>;
    ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            accountAddress: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }>, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[]>, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    }>, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        name: valibot.OptionalSchema<valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    }, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    }>, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined>;
    ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        name: valibot.OptionalSchema<valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    }, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    }>, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "authorizedRequest";
    auth: {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    } | {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    };
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
    ongoingAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    ongoingPersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
}>;
type WalletRequestResponseItems = Output<typeof WalletRequestResponseItems>;
declare const WalletRequestResponseItems: valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            accountAddress: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }>, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[]>, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    }>, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        name: valibot.OptionalSchema<valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    }, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    }>, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
    auth: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
        persona: valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>;
    }, undefined, {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
        persona: valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>;
        challenge: valibot.StringSchema<string>;
        proof: valibot.ObjectSchema<{
            publicKey: valibot.StringSchema<string>;
            signature: valibot.StringSchema<string>;
            curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
        }, undefined, {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        }>;
    }, undefined, {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    }>)[], {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
        persona: valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>;
    }, undefined, {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    }>)[], {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    } | {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    }>;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            accountAddress: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }>, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[]>, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    }>, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined>;
    ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            accountAddress: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }>, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[]>, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    }>, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        name: valibot.OptionalSchema<valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    }, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    }>, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined>;
    ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        name: valibot.OptionalSchema<valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    }, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    }>, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "authorizedRequest";
    auth: {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    } | {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    };
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
    ongoingAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    ongoingPersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
}>)[], {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
} | {
    discriminator: "authorizedRequest";
    auth: {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    } | {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    };
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
    ongoingAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    ongoingPersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
}>;
type WalletInteractionResponseItems = Output<typeof WalletInteractionResponseItems>;
declare const WalletInteractionResponseItems: valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"transaction", "transaction">;
    send: valibot.ObjectSchema<{
        transactionIntentHash: valibot.StringSchema<string>;
    }, undefined, {
        transactionIntentHash: string;
    }>;
}, undefined, {
    discriminator: "transaction";
    send: {
        transactionIntentHash: string;
    };
}> | valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            accountAddress: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }>, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[]>, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    }>, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        name: valibot.OptionalSchema<valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    }, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    }>, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
    auth: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
        persona: valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>;
    }, undefined, {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
        persona: valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>;
        challenge: valibot.StringSchema<string>;
        proof: valibot.ObjectSchema<{
            publicKey: valibot.StringSchema<string>;
            signature: valibot.StringSchema<string>;
            curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
        }, undefined, {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        }>;
    }, undefined, {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    }>)[], {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
        persona: valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>;
    }, undefined, {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    }>)[], {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    } | {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    }>;
    oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            accountAddress: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }>, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[]>, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    }>, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined>;
    ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
            accountAddress: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }>, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[]>, undefined, {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    }>, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined>;
    oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        name: valibot.OptionalSchema<valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    }, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    }>, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined>;
    ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        name: valibot.OptionalSchema<valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
    }, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    }>, undefined, {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined>;
}, undefined, {
    discriminator: "authorizedRequest";
    auth: {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    } | {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    };
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
    ongoingAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    ongoingPersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
}>)[], {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
} | {
    discriminator: "authorizedRequest";
    auth: {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    } | {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    };
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
    ongoingAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    ongoingPersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
}>)[], {
    discriminator: "transaction";
    send: {
        transactionIntentHash: string;
    };
} | {
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
} | {
    discriminator: "authorizedRequest";
    auth: {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithoutChallenge";
    } | {
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "loginWithChallenge";
    } | {
        persona: {
            label: string;
            identityAddress: string;
        };
        discriminator: "usePersona";
    };
    oneTimeAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    oneTimePersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
    ongoingAccounts?: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        challenge?: string | undefined;
        proofs?: {
            accountAddress: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
        }[] | undefined;
    } | undefined;
    ongoingPersonaData?: {
        name?: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        } | undefined;
        emailAddresses?: string[] | undefined;
        phoneNumbers?: string[] | undefined;
    } | undefined;
}>;
type WalletInteractionSuccessResponse = Output<typeof WalletInteractionSuccessResponse>;
declare const WalletInteractionSuccessResponse: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"success", "success">;
    interactionId: valibot.StringSchema<string>;
    items: valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"transaction", "transaction">;
        send: valibot.ObjectSchema<{
            transactionIntentHash: valibot.StringSchema<string>;
        }, undefined, {
            transactionIntentHash: string;
        }>;
    }, undefined, {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    }> | valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
        oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                address: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
                appearanceId: valibot.NumberSchema<number>;
            }, undefined, {
                address: string;
                label: string;
                appearanceId: number;
            }>, {
                address: string;
                label: string;
                appearanceId: number;
            }[]>;
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                accountAddress: valibot.StringSchema<string>;
                proof: valibot.ObjectSchema<{
                    publicKey: valibot.StringSchema<string>;
                    signature: valibot.StringSchema<string>;
                    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
                }, undefined, {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                }>;
            }, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }>, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[]>, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined>;
        }, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        }>, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined>;
        oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            name: valibot.OptionalSchema<valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined>;
            emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        }, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        }>, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined>;
    }, undefined, {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
        auth: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
            persona: valibot.ObjectSchema<{
                identityAddress: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
            }, undefined, {
                label: string;
                identityAddress: string;
            }>;
        }, undefined, {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
            persona: valibot.ObjectSchema<{
                identityAddress: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
            }, undefined, {
                label: string;
                identityAddress: string;
            }>;
            challenge: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        }>)[], {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
            persona: valibot.ObjectSchema<{
                identityAddress: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
            }, undefined, {
                label: string;
                identityAddress: string;
            }>;
        }, undefined, {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        }>)[], {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        }>;
        oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                address: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
                appearanceId: valibot.NumberSchema<number>;
            }, undefined, {
                address: string;
                label: string;
                appearanceId: number;
            }>, {
                address: string;
                label: string;
                appearanceId: number;
            }[]>;
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                accountAddress: valibot.StringSchema<string>;
                proof: valibot.ObjectSchema<{
                    publicKey: valibot.StringSchema<string>;
                    signature: valibot.StringSchema<string>;
                    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
                }, undefined, {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                }>;
            }, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }>, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[]>, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined>;
        }, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        }>, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined>;
        ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                address: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
                appearanceId: valibot.NumberSchema<number>;
            }, undefined, {
                address: string;
                label: string;
                appearanceId: number;
            }>, {
                address: string;
                label: string;
                appearanceId: number;
            }[]>;
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                accountAddress: valibot.StringSchema<string>;
                proof: valibot.ObjectSchema<{
                    publicKey: valibot.StringSchema<string>;
                    signature: valibot.StringSchema<string>;
                    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
                }, undefined, {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                }>;
            }, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }>, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[]>, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined>;
        }, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        }>, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined>;
        oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            name: valibot.OptionalSchema<valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined>;
            emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        }, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        }>, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined>;
        ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            name: valibot.OptionalSchema<valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined>;
            emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        }, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        }>, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined>;
    }, undefined, {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }>)[], {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }>)[], {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    } | {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }>;
}, undefined, {
    discriminator: "success";
    interactionId: string;
    items: {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    } | {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    };
}>;
type WalletInteractionFailureResponse = Output<typeof WalletInteractionFailureResponse>;
declare const WalletInteractionFailureResponse: valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"failure", "failure">;
    interactionId: valibot.StringSchema<string>;
    error: valibot.StringSchema<string>;
    message: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
}, undefined, {
    error: string;
    discriminator: "failure";
    interactionId: string;
    message?: string | undefined;
}>;
type WalletInteractionResponse = Output<typeof WalletInteractionResponse>;
declare const WalletInteractionResponse: valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"success", "success">;
    interactionId: valibot.StringSchema<string>;
    items: valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"transaction", "transaction">;
        send: valibot.ObjectSchema<{
            transactionIntentHash: valibot.StringSchema<string>;
        }, undefined, {
            transactionIntentHash: string;
        }>;
    }, undefined, {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    }> | valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
        oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                address: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
                appearanceId: valibot.NumberSchema<number>;
            }, undefined, {
                address: string;
                label: string;
                appearanceId: number;
            }>, {
                address: string;
                label: string;
                appearanceId: number;
            }[]>;
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                accountAddress: valibot.StringSchema<string>;
                proof: valibot.ObjectSchema<{
                    publicKey: valibot.StringSchema<string>;
                    signature: valibot.StringSchema<string>;
                    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
                }, undefined, {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                }>;
            }, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }>, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[]>, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined>;
        }, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        }>, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined>;
        oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            name: valibot.OptionalSchema<valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined>;
            emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        }, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        }>, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined>;
    }, undefined, {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
        auth: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
            persona: valibot.ObjectSchema<{
                identityAddress: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
            }, undefined, {
                label: string;
                identityAddress: string;
            }>;
        }, undefined, {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
            persona: valibot.ObjectSchema<{
                identityAddress: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
            }, undefined, {
                label: string;
                identityAddress: string;
            }>;
            challenge: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        }>)[], {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
            persona: valibot.ObjectSchema<{
                identityAddress: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
            }, undefined, {
                label: string;
                identityAddress: string;
            }>;
        }, undefined, {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        }>)[], {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        }>;
        oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                address: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
                appearanceId: valibot.NumberSchema<number>;
            }, undefined, {
                address: string;
                label: string;
                appearanceId: number;
            }>, {
                address: string;
                label: string;
                appearanceId: number;
            }[]>;
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                accountAddress: valibot.StringSchema<string>;
                proof: valibot.ObjectSchema<{
                    publicKey: valibot.StringSchema<string>;
                    signature: valibot.StringSchema<string>;
                    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
                }, undefined, {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                }>;
            }, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }>, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[]>, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined>;
        }, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        }>, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined>;
        ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                address: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
                appearanceId: valibot.NumberSchema<number>;
            }, undefined, {
                address: string;
                label: string;
                appearanceId: number;
            }>, {
                address: string;
                label: string;
                appearanceId: number;
            }[]>;
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                accountAddress: valibot.StringSchema<string>;
                proof: valibot.ObjectSchema<{
                    publicKey: valibot.StringSchema<string>;
                    signature: valibot.StringSchema<string>;
                    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
                }, undefined, {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                }>;
            }, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }>, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[]>, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined>;
        }, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        }>, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined>;
        oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            name: valibot.OptionalSchema<valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined>;
            emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        }, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        }>, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined>;
        ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            name: valibot.OptionalSchema<valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined>;
            emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        }, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        }>, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined>;
    }, undefined, {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }>)[], {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }>)[], {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    } | {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }>;
}, undefined, {
    discriminator: "success";
    interactionId: string;
    items: {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    } | {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    };
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"failure", "failure">;
    interactionId: valibot.StringSchema<string>;
    error: valibot.StringSchema<string>;
    message: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
}, undefined, {
    error: string;
    discriminator: "failure";
    interactionId: string;
    message?: string | undefined;
}>)[], {
    discriminator: "success";
    interactionId: string;
    items: {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    } | {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    };
} | {
    error: string;
    discriminator: "failure";
    interactionId: string;
    message?: string | undefined;
}>;
declare const extensionInteractionDiscriminator: {
    readonly extensionStatus: "extensionStatus";
    readonly openPopup: "openPopup";
    readonly cancelWalletInteraction: "cancelWalletInteraction";
    readonly walletInteraction: "walletInteraction";
};
declare const StatusExtensionInteraction: valibot.ObjectSchema<{
    interactionId: valibot.StringSchema<string>;
    discriminator: valibot.LiteralSchema<"extensionStatus", "extensionStatus">;
}, undefined, {
    discriminator: "extensionStatus";
    interactionId: string;
}>;
type StatusExtensionInteraction = Output<typeof StatusExtensionInteraction>;
declare const OpenPopupExtensionInteraction: valibot.ObjectSchema<{
    interactionId: valibot.StringSchema<string>;
    discriminator: valibot.LiteralSchema<"openPopup", "openPopup">;
}, undefined, {
    discriminator: "openPopup";
    interactionId: string;
}>;
type OpenPopupExtensionInteraction = Output<typeof OpenPopupExtensionInteraction>;
type WalletInteractionExtensionInteraction = Output<typeof WalletInteractionExtensionInteraction>;
declare const WalletInteractionExtensionInteraction: valibot.ObjectSchema<{
    interactionId: valibot.StringSchema<string>;
    discriminator: valibot.LiteralSchema<"walletInteraction", "walletInteraction">;
    interaction: valibot.ObjectSchema<{
        interactionId: valibot.StringSchema<string>;
        metadata: valibot.ObjectSchema<{
            version: valibot.LiteralSchema<2, 2>;
            networkId: valibot.NumberSchema<number>;
            dAppDefinitionAddress: valibot.StringSchema<string>;
            origin: valibot.StringSchema<string>;
        }, undefined, {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        }>;
        items: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
            oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
                numberOfAccounts: valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>;
            }, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            }>, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined>;
            oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
                numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
                numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
            }, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            }>, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined>;
        }, undefined, {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
            auth: valibot.UnionSchema<(valibot.ObjectSchema<{
                discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
                identityAddress: valibot.StringSchema<string>;
            }, undefined, {
                identityAddress: string;
                discriminator: "usePersona";
            }> | valibot.UnionSchema<(valibot.ObjectSchema<{
                discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
            }, undefined, {
                discriminator: "loginWithoutChallenge";
            }> | valibot.ObjectSchema<{
                discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
                challenge: valibot.StringSchema<string>;
            }, undefined, {
                challenge: string;
                discriminator: "loginWithChallenge";
            }>)[], {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            }>)[], {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            }>;
            reset: valibot.OptionalSchema<valibot.ObjectSchema<{
                accounts: valibot.BooleanSchema<boolean>;
                personaData: valibot.BooleanSchema<boolean>;
            }, undefined, {
                accounts: boolean;
                personaData: boolean;
            }>, undefined, {
                accounts: boolean;
                personaData: boolean;
            } | undefined>;
            oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
                numberOfAccounts: valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>;
            }, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            }>, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined>;
            ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
                numberOfAccounts: valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>;
            }, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            }>, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined>;
            oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
                numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
                numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
            }, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            }>, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined>;
            ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
                numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
                numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
            }, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            }>, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined>;
        }, undefined, {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        }>)[], {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"transaction", "transaction">;
            send: valibot.ObjectSchema<{
                transactionManifest: valibot.StringSchema<string>;
                version: valibot.NumberSchema<number>;
                blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
                message: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            }, undefined, {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            }>;
        }, undefined, {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"cancelRequest", "cancelRequest">;
        }, undefined, {
            discriminator: "cancelRequest";
        }>)[], {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        } | {
            discriminator: "cancelRequest";
        }>;
    }, undefined, {
        interactionId: string;
        metadata: {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        };
        items: {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        } | {
            discriminator: "cancelRequest";
        };
    }>;
    sessionId: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
}, undefined, {
    discriminator: "walletInteraction";
    interactionId: string;
    interaction: {
        interactionId: string;
        metadata: {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        };
        items: {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        } | {
            discriminator: "cancelRequest";
        };
    };
    sessionId?: string | undefined;
}>;
type CancelWalletInteractionExtensionInteraction = Output<typeof CancelWalletInteractionExtensionInteraction>;
declare const CancelWalletInteractionExtensionInteraction: valibot.ObjectSchema<{
    interactionId: valibot.StringSchema<string>;
    discriminator: valibot.LiteralSchema<"cancelWalletInteraction", "cancelWalletInteraction">;
    metadata: valibot.ObjectSchema<{
        version: valibot.LiteralSchema<2, 2>;
        networkId: valibot.NumberSchema<number>;
        dAppDefinitionAddress: valibot.StringSchema<string>;
        origin: valibot.StringSchema<string>;
    }, undefined, {
        version: 2;
        networkId: number;
        dAppDefinitionAddress: string;
        origin: string;
    }>;
}, undefined, {
    discriminator: "cancelWalletInteraction";
    interactionId: string;
    metadata: {
        version: 2;
        networkId: number;
        dAppDefinitionAddress: string;
        origin: string;
    };
}>;
declare const ExtensionInteraction: valibot.UnionSchema<(valibot.ObjectSchema<{
    interactionId: valibot.StringSchema<string>;
    discriminator: valibot.LiteralSchema<"extensionStatus", "extensionStatus">;
}, undefined, {
    discriminator: "extensionStatus";
    interactionId: string;
}> | valibot.ObjectSchema<{
    interactionId: valibot.StringSchema<string>;
    discriminator: valibot.LiteralSchema<"openPopup", "openPopup">;
}, undefined, {
    discriminator: "openPopup";
    interactionId: string;
}> | valibot.ObjectSchema<{
    interactionId: valibot.StringSchema<string>;
    discriminator: valibot.LiteralSchema<"walletInteraction", "walletInteraction">;
    interaction: valibot.ObjectSchema<{
        interactionId: valibot.StringSchema<string>;
        metadata: valibot.ObjectSchema<{
            version: valibot.LiteralSchema<2, 2>;
            networkId: valibot.NumberSchema<number>;
            dAppDefinitionAddress: valibot.StringSchema<string>;
            origin: valibot.StringSchema<string>;
        }, undefined, {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        }>;
        items: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
            oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
                numberOfAccounts: valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>;
            }, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            }>, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined>;
            oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
                numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
                numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
            }, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            }>, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined>;
        }, undefined, {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
            auth: valibot.UnionSchema<(valibot.ObjectSchema<{
                discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
                identityAddress: valibot.StringSchema<string>;
            }, undefined, {
                identityAddress: string;
                discriminator: "usePersona";
            }> | valibot.UnionSchema<(valibot.ObjectSchema<{
                discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
            }, undefined, {
                discriminator: "loginWithoutChallenge";
            }> | valibot.ObjectSchema<{
                discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
                challenge: valibot.StringSchema<string>;
            }, undefined, {
                challenge: string;
                discriminator: "loginWithChallenge";
            }>)[], {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            }>)[], {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            }>;
            reset: valibot.OptionalSchema<valibot.ObjectSchema<{
                accounts: valibot.BooleanSchema<boolean>;
                personaData: valibot.BooleanSchema<boolean>;
            }, undefined, {
                accounts: boolean;
                personaData: boolean;
            }>, undefined, {
                accounts: boolean;
                personaData: boolean;
            } | undefined>;
            oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
                numberOfAccounts: valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>;
            }, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            }>, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined>;
            ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
                numberOfAccounts: valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>;
            }, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            }>, undefined, {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined>;
            oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
                numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
                numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
            }, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            }>, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined>;
            ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
                isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
                numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
                numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                    quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                    quantity: valibot.NumberSchema<number>;
                }, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                }>, undefined, {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined>;
            }, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            }>, undefined, {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined>;
        }, undefined, {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        }>)[], {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"transaction", "transaction">;
            send: valibot.ObjectSchema<{
                transactionManifest: valibot.StringSchema<string>;
                version: valibot.NumberSchema<number>;
                blobs: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
                message: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            }, undefined, {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            }>;
        }, undefined, {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"cancelRequest", "cancelRequest">;
        }, undefined, {
            discriminator: "cancelRequest";
        }>)[], {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        } | {
            discriminator: "cancelRequest";
        }>;
    }, undefined, {
        interactionId: string;
        metadata: {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        };
        items: {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        } | {
            discriminator: "cancelRequest";
        };
    }>;
    sessionId: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
}, undefined, {
    discriminator: "walletInteraction";
    interactionId: string;
    interaction: {
        interactionId: string;
        metadata: {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        };
        items: {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        } | {
            discriminator: "cancelRequest";
        };
    };
    sessionId?: string | undefined;
}> | valibot.ObjectSchema<{
    interactionId: valibot.StringSchema<string>;
    discriminator: valibot.LiteralSchema<"cancelWalletInteraction", "cancelWalletInteraction">;
    metadata: valibot.ObjectSchema<{
        version: valibot.LiteralSchema<2, 2>;
        networkId: valibot.NumberSchema<number>;
        dAppDefinitionAddress: valibot.StringSchema<string>;
        origin: valibot.StringSchema<string>;
    }, undefined, {
        version: 2;
        networkId: number;
        dAppDefinitionAddress: string;
        origin: string;
    }>;
}, undefined, {
    discriminator: "cancelWalletInteraction";
    interactionId: string;
    metadata: {
        version: 2;
        networkId: number;
        dAppDefinitionAddress: string;
        origin: string;
    };
}>)[], {
    discriminator: "extensionStatus";
    interactionId: string;
} | {
    discriminator: "openPopup";
    interactionId: string;
} | {
    discriminator: "walletInteraction";
    interactionId: string;
    interaction: {
        interactionId: string;
        metadata: {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        };
        items: {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        } | {
            discriminator: "cancelRequest";
        };
    };
    sessionId?: string | undefined;
} | {
    discriminator: "cancelWalletInteraction";
    interactionId: string;
    metadata: {
        version: 2;
        networkId: number;
        dAppDefinitionAddress: string;
        origin: string;
    };
}>;
type ExtensionInteraction = Output<typeof ExtensionInteraction>;
declare const messageLifeCycleEventType: {
    readonly extensionStatus: "extensionStatus";
    readonly receivedByExtension: "receivedByExtension";
    readonly receivedByWallet: "receivedByWallet";
    readonly requestCancelSuccess: "requestCancelSuccess";
    readonly requestCancelFail: "requestCancelFail";
};
declare const MessageLifeCycleExtensionStatusEvent: valibot.ObjectSchema<{
    eventType: valibot.LiteralSchema<"extensionStatus", "extensionStatus">;
    interactionId: valibot.StringSchema<string>;
    isWalletLinked: valibot.BooleanSchema<boolean>;
    isExtensionAvailable: valibot.BooleanSchema<boolean>;
    canHandleSessions: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
}, undefined, {
    interactionId: string;
    eventType: "extensionStatus";
    isWalletLinked: boolean;
    isExtensionAvailable: boolean;
    canHandleSessions?: boolean | undefined;
}>;
type MessageLifeCycleExtensionStatusEvent = Output<typeof MessageLifeCycleExtensionStatusEvent>;
declare const MessageLifeCycleEvent: valibot.ObjectSchema<{
    eventType: valibot.UnionSchema<(valibot.LiteralSchema<"extensionStatus", "extensionStatus"> | valibot.LiteralSchema<"receivedByExtension", "receivedByExtension"> | valibot.LiteralSchema<"receivedByWallet", "receivedByWallet"> | valibot.LiteralSchema<"requestCancelSuccess", "requestCancelSuccess"> | valibot.LiteralSchema<"requestCancelFail", "requestCancelFail">)[], "extensionStatus" | "receivedByExtension" | "receivedByWallet" | "requestCancelSuccess" | "requestCancelFail">;
    interactionId: valibot.StringSchema<string>;
}, undefined, {
    interactionId: string;
    eventType: "extensionStatus" | "receivedByExtension" | "receivedByWallet" | "requestCancelSuccess" | "requestCancelFail";
}>;
type MessageLifeCycleEvent = Output<typeof MessageLifeCycleEvent>;
type IncomingMessage = Output<typeof IncomingMessage>;
declare const IncomingMessage: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"success", "success">;
    interactionId: valibot.StringSchema<string>;
    items: valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"transaction", "transaction">;
        send: valibot.ObjectSchema<{
            transactionIntentHash: valibot.StringSchema<string>;
        }, undefined, {
            transactionIntentHash: string;
        }>;
    }, undefined, {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    }> | valibot.UnionSchema<(valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"unauthorizedRequest", "unauthorizedRequest">;
        oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                address: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
                appearanceId: valibot.NumberSchema<number>;
            }, undefined, {
                address: string;
                label: string;
                appearanceId: number;
            }>, {
                address: string;
                label: string;
                appearanceId: number;
            }[]>;
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                accountAddress: valibot.StringSchema<string>;
                proof: valibot.ObjectSchema<{
                    publicKey: valibot.StringSchema<string>;
                    signature: valibot.StringSchema<string>;
                    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
                }, undefined, {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                }>;
            }, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }>, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[]>, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined>;
        }, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        }>, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined>;
        oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            name: valibot.OptionalSchema<valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined>;
            emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        }, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        }>, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined>;
    }, undefined, {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }> | valibot.ObjectSchema<{
        discriminator: valibot.LiteralSchema<"authorizedRequest", "authorizedRequest">;
        auth: valibot.UnionSchema<(valibot.UnionSchema<(valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"loginWithoutChallenge", "loginWithoutChallenge">;
            persona: valibot.ObjectSchema<{
                identityAddress: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
            }, undefined, {
                label: string;
                identityAddress: string;
            }>;
        }, undefined, {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"loginWithChallenge", "loginWithChallenge">;
            persona: valibot.ObjectSchema<{
                identityAddress: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
            }, undefined, {
                label: string;
                identityAddress: string;
            }>;
            challenge: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
        }, undefined, {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        }>)[], {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        }> | valibot.ObjectSchema<{
            discriminator: valibot.LiteralSchema<"usePersona", "usePersona">;
            persona: valibot.ObjectSchema<{
                identityAddress: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
            }, undefined, {
                label: string;
                identityAddress: string;
            }>;
        }, undefined, {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        }>)[], {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        }>;
        oneTimeAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                address: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
                appearanceId: valibot.NumberSchema<number>;
            }, undefined, {
                address: string;
                label: string;
                appearanceId: number;
            }>, {
                address: string;
                label: string;
                appearanceId: number;
            }[]>;
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                accountAddress: valibot.StringSchema<string>;
                proof: valibot.ObjectSchema<{
                    publicKey: valibot.StringSchema<string>;
                    signature: valibot.StringSchema<string>;
                    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
                }, undefined, {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                }>;
            }, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }>, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[]>, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined>;
        }, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        }>, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined>;
        ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            accounts: valibot.ArraySchema<valibot.ObjectSchema<{
                address: valibot.StringSchema<string>;
                label: valibot.StringSchema<string>;
                appearanceId: valibot.NumberSchema<number>;
            }, undefined, {
                address: string;
                label: string;
                appearanceId: number;
            }>, {
                address: string;
                label: string;
                appearanceId: number;
            }[]>;
            challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
            proofs: valibot.OptionalSchema<valibot.ArraySchema<valibot.ObjectSchema<{
                accountAddress: valibot.StringSchema<string>;
                proof: valibot.ObjectSchema<{
                    publicKey: valibot.StringSchema<string>;
                    signature: valibot.StringSchema<string>;
                    curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
                }, undefined, {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                }>;
            }, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }>, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[]>, undefined, {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined>;
        }, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        }>, undefined, {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined>;
        oneTimePersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            name: valibot.OptionalSchema<valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined>;
            emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        }, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        }>, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined>;
        ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            name: valibot.OptionalSchema<valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined>;
            emailAddresses: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
            phoneNumbers: valibot.OptionalSchema<valibot.ArraySchema<valibot.StringSchema<string>, string[]>, undefined, string[] | undefined>;
        }, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        }>, undefined, {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined>;
    }, undefined, {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }>)[], {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }>)[], {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    } | {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    }>;
}, undefined, {
    discriminator: "success";
    interactionId: string;
    items: {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    } | {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    };
}> | valibot.ObjectSchema<{
    discriminator: valibot.LiteralSchema<"failure", "failure">;
    interactionId: valibot.StringSchema<string>;
    error: valibot.StringSchema<string>;
    message: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
}, undefined, {
    error: string;
    discriminator: "failure";
    interactionId: string;
    message?: string | undefined;
}>)[], {
    discriminator: "success";
    interactionId: string;
    items: {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    } | {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    };
} | {
    error: string;
    discriminator: "failure";
    interactionId: string;
    message?: string | undefined;
}> | valibot.ObjectSchema<{
    eventType: valibot.UnionSchema<(valibot.LiteralSchema<"extensionStatus", "extensionStatus"> | valibot.LiteralSchema<"receivedByExtension", "receivedByExtension"> | valibot.LiteralSchema<"receivedByWallet", "receivedByWallet"> | valibot.LiteralSchema<"requestCancelSuccess", "requestCancelSuccess"> | valibot.LiteralSchema<"requestCancelFail", "requestCancelFail">)[], "extensionStatus" | "receivedByExtension" | "receivedByWallet" | "requestCancelSuccess" | "requestCancelFail">;
    interactionId: valibot.StringSchema<string>;
}, undefined, {
    interactionId: string;
    eventType: "extensionStatus" | "receivedByExtension" | "receivedByWallet" | "requestCancelSuccess" | "requestCancelFail";
}>)[], {
    discriminator: "success";
    interactionId: string;
    items: {
        discriminator: "transaction";
        send: {
            transactionIntentHash: string;
        };
    } | {
        discriminator: "unauthorizedRequest";
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    } | {
        discriminator: "authorizedRequest";
        auth: {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithoutChallenge";
        } | {
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "loginWithChallenge";
        } | {
            persona: {
                label: string;
                identityAddress: string;
            };
            discriminator: "usePersona";
        };
        oneTimeAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        oneTimePersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
        ongoingAccounts?: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            challenge?: string | undefined;
            proofs?: {
                accountAddress: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
            }[] | undefined;
        } | undefined;
        ongoingPersonaData?: {
            name?: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            } | undefined;
            emailAddresses?: string[] | undefined;
            phoneNumbers?: string[] | undefined;
        } | undefined;
    };
} | {
    error: string;
    discriminator: "failure";
    interactionId: string;
    message?: string | undefined;
} | {
    interactionId: string;
    eventType: "extensionStatus" | "receivedByExtension" | "receivedByWallet" | "requestCancelSuccess" | "requestCancelFail";
}>;
declare const eventType: {
    readonly outgoingMessage: "radix#chromeExtension#send";
    readonly incomingMessage: "radix#chromeExtension#receive";
};
type CallbackFns = {
    eventCallback: (messageEvent: MessageLifeCycleEvent['eventType']) => void;
    requestControl: (api: {
        cancelRequest: () => ResultAsync<'requestCancelSuccess', 'requestCancelFail'>;
        getRequest: () => WalletInteraction;
    }) => void;
};
declare const Types: valibot.UnionSchema<(valibot.LiteralSchema<"offer", "offer"> | valibot.LiteralSchema<"answer", "answer"> | valibot.LiteralSchema<"iceCandidate", "iceCandidate"> | valibot.LiteralSchema<"iceCandidates", "iceCandidates">)[], "offer" | "answer" | "iceCandidate" | "iceCandidates">;
declare const Sources: valibot.UnionSchema<(valibot.LiteralSchema<"wallet", "wallet"> | valibot.LiteralSchema<"extension", "extension">)[], "wallet" | "extension">;
declare const SignalingServerMessage: valibot.ObjectSchema<{
    requestId: valibot.StringSchema<string>;
    targetClientId: valibot.StringSchema<string>;
    encryptedPayload: valibot.StringSchema<string>;
    source: valibot.OptionalSchema<valibot.UnionSchema<(valibot.LiteralSchema<"wallet", "wallet"> | valibot.LiteralSchema<"extension", "extension">)[], "wallet" | "extension">, undefined, "wallet" | "extension" | undefined>;
    connectionId: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
}, undefined, {
    requestId: string;
    targetClientId: string;
    encryptedPayload: string;
    source?: "wallet" | "extension" | undefined;
    connectionId?: string | undefined;
}>;
declare const AnswerIO: valibot.ObjectSchema<{
    requestId: valibot.StringSchema<string>;
    targetClientId: valibot.StringSchema<string>;
    encryptedPayload: valibot.StringSchema<string>;
    source: valibot.OptionalSchema<valibot.UnionSchema<(valibot.LiteralSchema<"wallet", "wallet"> | valibot.LiteralSchema<"extension", "extension">)[], "wallet" | "extension">, undefined, "wallet" | "extension" | undefined>;
    connectionId: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
} & {
    method: valibot.LiteralSchema<"answer", "answer">;
    payload: valibot.ObjectSchema<{
        sdp: valibot.StringSchema<string>;
    }, undefined, {
        sdp: string;
    }>;
}, undefined, {
    requestId: string;
    targetClientId: string;
    encryptedPayload: string;
    method: "answer";
    payload: {
        sdp: string;
    };
    source?: "wallet" | "extension" | undefined;
    connectionId?: string | undefined;
}>;
declare const OfferIO: valibot.ObjectSchema<{
    requestId: valibot.StringSchema<string>;
    targetClientId: valibot.StringSchema<string>;
    encryptedPayload: valibot.StringSchema<string>;
    source: valibot.OptionalSchema<valibot.UnionSchema<(valibot.LiteralSchema<"wallet", "wallet"> | valibot.LiteralSchema<"extension", "extension">)[], "wallet" | "extension">, undefined, "wallet" | "extension" | undefined>;
    connectionId: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
} & {
    method: valibot.LiteralSchema<"offer", "offer">;
    payload: valibot.ObjectSchema<{
        sdp: valibot.StringSchema<string>;
    }, undefined, {
        sdp: string;
    }>;
}, undefined, {
    requestId: string;
    targetClientId: string;
    encryptedPayload: string;
    method: "offer";
    payload: {
        sdp: string;
    };
    source?: "wallet" | "extension" | undefined;
    connectionId?: string | undefined;
}>;
declare const IceCandidatePayloadIO: valibot.ObjectSchema<{
    candidate: valibot.StringSchema<string>;
    sdpMid: valibot.StringSchema<string>;
    sdpMLineIndex: valibot.NumberSchema<number>;
}, undefined, {
    candidate: string;
    sdpMid: string;
    sdpMLineIndex: number;
}>;
declare const IceCandidateIO: valibot.ObjectSchema<{
    requestId: valibot.StringSchema<string>;
    targetClientId: valibot.StringSchema<string>;
    encryptedPayload: valibot.StringSchema<string>;
    source: valibot.OptionalSchema<valibot.UnionSchema<(valibot.LiteralSchema<"wallet", "wallet"> | valibot.LiteralSchema<"extension", "extension">)[], "wallet" | "extension">, undefined, "wallet" | "extension" | undefined>;
    connectionId: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
} & {
    method: valibot.LiteralSchema<"iceCandidate", "iceCandidate">;
    payload: valibot.ObjectSchema<{
        candidate: valibot.StringSchema<string>;
        sdpMid: valibot.StringSchema<string>;
        sdpMLineIndex: valibot.NumberSchema<number>;
    }, undefined, {
        candidate: string;
        sdpMid: string;
        sdpMLineIndex: number;
    }>;
}, undefined, {
    requestId: string;
    targetClientId: string;
    encryptedPayload: string;
    method: "iceCandidate";
    payload: {
        candidate: string;
        sdpMid: string;
        sdpMLineIndex: number;
    };
    source?: "wallet" | "extension" | undefined;
    connectionId?: string | undefined;
}>;
declare const IceCandidatesIO: valibot.ObjectSchema<{
    requestId: valibot.StringSchema<string>;
    targetClientId: valibot.StringSchema<string>;
    encryptedPayload: valibot.StringSchema<string>;
    source: valibot.OptionalSchema<valibot.UnionSchema<(valibot.LiteralSchema<"wallet", "wallet"> | valibot.LiteralSchema<"extension", "extension">)[], "wallet" | "extension">, undefined, "wallet" | "extension" | undefined>;
    connectionId: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
} & {
    method: valibot.LiteralSchema<"iceCandidates", "iceCandidates">;
    payload: valibot.ArraySchema<valibot.ObjectSchema<{
        candidate: valibot.StringSchema<string>;
        sdpMid: valibot.StringSchema<string>;
        sdpMLineIndex: valibot.NumberSchema<number>;
    }, undefined, {
        candidate: string;
        sdpMid: string;
        sdpMLineIndex: number;
    }>, {
        candidate: string;
        sdpMid: string;
        sdpMLineIndex: number;
    }[]>;
}, undefined, {
    requestId: string;
    targetClientId: string;
    encryptedPayload: string;
    method: "iceCandidates";
    payload: {
        candidate: string;
        sdpMid: string;
        sdpMLineIndex: number;
    }[];
    source?: "wallet" | "extension" | undefined;
    connectionId?: string | undefined;
}>;
type Answer = Output<typeof AnswerIO>;
type Offer = Output<typeof OfferIO>;
type IceCandidate = Output<typeof IceCandidateIO>;
type IceCandidates = Output<typeof IceCandidatesIO>;
type MessagePayloadTypes = Output<typeof Types>;
type MessageSources = Output<typeof Sources>;
type DataTypes = Answer | IceCandidate | Offer | IceCandidates;
type Confirmation = {
    info: 'confirmation';
    requestId: DataTypes['requestId'];
};
type RemoteData<T extends DataTypes = DataTypes> = {
    info: 'remoteData';
    remoteClientId: string;
    requestId: T['requestId'];
    data: T;
};
type RemoteClientDisconnected = {
    info: 'remoteClientDisconnected';
    remoteClientId: string;
};
type RemoteClientJustConnected = {
    info: 'remoteClientJustConnected';
    remoteClientId: string;
};
type RemoteClientIsAlreadyConnected = {
    info: 'remoteClientIsAlreadyConnected';
    remoteClientId: string;
};
type MissingRemoteClientError = {
    info: 'missingRemoteClientError';
    requestId: DataTypes['requestId'];
};
type InvalidMessageError = {
    info: 'invalidMessageError';
    error: string;
    data: string;
};
type ValidationError = {
    info: 'validationError';
    requestId: DataTypes['requestId'];
    error: ValiError;
};
type SignalingServerResponse = Confirmation | RemoteData | RemoteClientJustConnected | RemoteClientIsAlreadyConnected | RemoteClientDisconnected | MissingRemoteClientError | InvalidMessageError | ValidationError;
type SignalingServerErrorResponse = RemoteClientDisconnected | MissingRemoteClientError | InvalidMessageError | ValidationError;

type ExponentialBackoffInput = {
    multiplier?: number;
    maxDelayTime?: number;
    timeout?: number;
    interval?: number;
};
type ExponentialBackoff = typeof ExponentialBackoff;
declare const ExponentialBackoff: ({ maxDelayTime, multiplier, timeout, interval, }?: ExponentialBackoffInput) => {
    trigger: Subject<void>;
    withBackoff$: Observable<Result<number, {
        error: string;
    }>>;
};

declare const fetchWrapper: <R = unknown, ER = unknown>(fetchable: ReturnType<typeof fetch>) => ResultAsync<{
    status: number;
    data: R;
}, {
    status: number;
    error?: Error;
    reason: string;
    data?: ER;
}>;

declare const isMobile: (userAgent?: string) => boolean;

type Logger = ReturnType<typeof Logger>;
declare const Logger: (minLevel?: number) => Logger$1<unknown>;

declare const parseJSON: <T = Record<string, any>>(text: string) => Result<T, Error>;

declare const removeUndefined: <T>(input: T) => neverthrow.Result<T, Error>;

declare const stringify: (input: any) => Result<string, Error>;

declare const typedError: <E = Error>(error: unknown) => E;

type SdkError = {
    error: string;
    interactionId: string;
    message?: string;
    jsError?: unknown;
};
declare const SdkError: (error: string, interactionId: string, message?: string, jsError?: unknown) => SdkError;

declare const unwrapObservable: (input: Observable<Result<any, SdkError>>) => ResultAsync<any, SdkError>;

declare const validateWalletResponse: (walletResponse: unknown) => ResultAsync<WalletInteractionSuccessResponse, SdkError>;

declare const generateRolaChallenge: () => string;

declare const validateRolaChallenge: (challenge?: unknown) => boolean;

type ConnectButtonStatus = (typeof ConnectButtonStatus)[keyof typeof ConnectButtonStatus];
declare const ConnectButtonStatus: {
    readonly pending: "pending";
    readonly success: "success";
    readonly default: "default";
    readonly error: "error";
};
type ConnectButtonModuleOutput = {
    status$: Observable<RadixButtonStatus>;
    onConnect$: Observable<{
        challenge: string;
    } | undefined>;
    onDisconnect$: Observable<void>;
    onUpdateSharedAccounts$: Observable<void>;
    onShowPopover$: Observable<void>;
    onCancelRequestItem$: Observable<string>;
    onLinkClick$: Observable<{
        type: 'account' | 'transaction' | 'showQrCode' | 'setupGuide' | 'getWallet';
        data: string;
    }>;
    setStatus: (value: RadixButtonStatus) => void;
    setMode: (value: 'light' | 'dark') => void;
    setTheme: (value: RadixButtonTheme) => void;
    setActiveTab: (value: 'sharing' | 'requests') => void;
    setIsMobile: (value: boolean) => void;
    setIsWalletLinked: (value: boolean) => void;
    setIsExtensionAvailable: (value: boolean) => void;
    setConnected: (value: boolean) => void;
    setLoggedInTimestamp: (value: string) => void;
    setRequestItems: (value: RequestItem[]) => void;
    setAccounts: (value: Account$1[]) => void;
    setPersonaData: (value: {
        value: string;
        field: string;
    }[]) => void;
    setPersonaLabel: (value: string) => void;
    setDappName: (value: string) => void;
    destroy: () => void;
    disconnect: () => void;
};

type ConnectButtonSubjects = ReturnType<typeof ConnectButtonSubjects>;
declare const ConnectButtonSubjects: () => {
    onConnect: Subject<{
        challenge: string;
    } | undefined>;
    onDisconnect: Subject<void>;
    onUpdateSharedAccounts: Subject<void>;
    connected: ReplaySubject<boolean>;
    requestItems: BehaviorSubject<RequestItem[]>;
    onCancelRequestItem: Subject<string>;
    onIgnoreTransactionItem: Subject<string>;
    accounts: BehaviorSubject<Account$1[]>;
    onShowPopover: Subject<void>;
    status: BehaviorSubject<ConnectButtonStatus>;
    loggedInTimestamp: BehaviorSubject<string>;
    isMobile: BehaviorSubject<boolean>;
    isWalletLinked: BehaviorSubject<boolean>;
    showPopoverMenu: BehaviorSubject<boolean>;
    isExtensionAvailable: BehaviorSubject<boolean>;
    fullWidth: BehaviorSubject<boolean>;
    activeTab: BehaviorSubject<"sharing" | "requests">;
    mode: BehaviorSubject<"light" | "dark">;
    theme: BehaviorSubject<"radix-blue" | "black" | "white-with-outline" | "white">;
    avatarUrl: BehaviorSubject<string>;
    personaLabel: BehaviorSubject<string>;
    personaData: BehaviorSubject<{
        value: string;
        field: string;
    }[]>;
    dAppName: BehaviorSubject<string>;
    onLinkClick: Subject<{
        type: 'account' | 'transaction' | 'setupGuide' | 'showQrCode' | 'getWallet';
        data: string;
    }>;
};

type KeyPairProvider = (privateKeyHex?: string) => {
    getPrivateKey: () => string;
    x25519: {
        getPublicKey: () => string;
        calculateSharedSecret: (publicKeyHex: string, dAppDefinitionAddress: string) => Result<string, Error>;
    };
    ed25519: {
        getPublicKey: () => string;
        sign: (messageHex: string) => Result<string, Error>;
    };
};
type Curve25519 = ReturnType<typeof Curve25519>;
declare const Curve25519: KeyPairProvider;

declare const blake2b: (input: Buffer) => Result<Buffer, Error>;

type AccountsRequestBuilder = {
    atLeast: (n: number) => AccountsRequestBuilder;
    exactly: (n: number) => AccountsRequestBuilder;
    withProof: (value?: boolean) => AccountsRequestBuilder;
    reset: (value?: boolean) => AccountsRequestBuilder;
};
type OneTimeAccountsRequestBuilder = {
    atLeast: (n: number) => OneTimeAccountsRequestBuilder;
    exactly: (n: number) => OneTimeAccountsRequestBuilder;
    withProof: (value?: boolean) => OneTimeAccountsRequestBuilder;
};
type AccountsDataRequest = Output<typeof AccountsDataRequestSchema>;
declare const AccountsDataRequestSchema: valibot.ObjectSchema<{
    numberOfAccounts: valibot.ObjectSchema<{
        quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
        quantity: valibot.NumberSchema<number>;
    }, undefined, {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    }>;
    withProof: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
    reset: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
}, undefined, {
    numberOfAccounts: {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    };
    reset?: boolean | undefined;
    withProof?: boolean | undefined;
}>;

type PersonaRequestBuilder = {
    withProof: (value?: boolean) => PersonaRequestBuilder;
};
type PersonaRequest = Output<typeof schema>;
declare const schema: valibot.ObjectSchema<{
    withProof: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
}, undefined, {
    withProof?: boolean | undefined;
}>;

type PersonaDataRequestBuilder = {
    fullName: (value?: boolean) => PersonaDataRequestBuilder;
    emailAddresses: (value?: boolean) => PersonaDataRequestBuilder;
    phoneNumbers: (value?: boolean) => PersonaDataRequestBuilder;
    reset: (value?: boolean) => PersonaDataRequestBuilder;
};
type OneTimePersonaDataRequestBuilder = {
    fullName: (value?: boolean) => PersonaDataRequestBuilder;
    emailAddresses: (value?: boolean) => PersonaDataRequestBuilder;
    phoneNumbers: (value?: boolean) => PersonaDataRequestBuilder;
};
type PersonaDataRequest = Output<typeof PersonaDataRequestSchema>;
declare const PersonaDataRequestSchema: valibot.ObjectSchema<valibot.PartialObjectEntries<{
    fullName: valibot.BooleanSchema<boolean>;
    emailAddresses: valibot.ObjectSchema<{
        quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
        quantity: valibot.NumberSchema<number>;
    }, undefined, {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    }>;
    phoneNumbers: valibot.ObjectSchema<{
        quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
        quantity: valibot.NumberSchema<number>;
    }, undefined, {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    }>;
    reset: valibot.BooleanSchema<boolean>;
}>, undefined, {
    emailAddresses?: {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    } | undefined;
    phoneNumbers?: {
        quantifier: "exactly" | "atLeast";
        quantity: number;
    } | undefined;
    reset?: boolean | undefined;
    fullName?: boolean | undefined;
}>;

type DataRequestBuilderItem = AccountsRequestBuilder | PersonaDataRequestBuilder | PersonaRequestBuilder | ConfigRequestBuilder;
type OneTimeDataRequestBuilderItem = OneTimeAccountsRequestBuilder | OneTimePersonaDataRequestBuilder;
type DataRequestState = Partial<{
    accounts: AccountsDataRequest;
} & {
    personaData: PersonaDataRequest;
} & {
    persona: PersonaRequest;
}>;
type ConfigRequestBuilder = {};
declare const config: (data: DataRequestState) => {
    _toObject: () => {
        accounts?: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            reset?: boolean | undefined;
            withProof?: boolean | undefined;
        } | undefined;
        personaData?: {
            emailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            phoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            reset?: boolean | undefined;
            fullName?: boolean | undefined;
        } | undefined;
        persona?: {
            withProof?: boolean | undefined;
        } | undefined;
    };
};
type DataRequestBuilder = {
    accounts: () => AccountsRequestBuilder;
    personaData: (input?: PersonaDataRequest) => PersonaDataRequestBuilder;
    persona: (input?: PersonaRequest) => PersonaRequestBuilder;
    config: (input: DataRequestState) => ConfigRequestBuilder;
};
declare const DataRequestBuilder: DataRequestBuilder;
type OneTimeDataRequestBuilder = {
    accounts: () => OneTimeAccountsRequestBuilder;
    personaData: (input?: PersonaDataRequest) => OneTimePersonaDataRequestBuilder;
};
declare const OneTimeDataRequestBuilder: OneTimeDataRequestBuilder;

declare const proofType: {
    readonly persona: "persona";
    readonly account: "account";
};
type SignedChallengePersona = Output<typeof SignedChallengePersona>;
declare const SignedChallengePersona: valibot.ObjectSchema<{
    challenge: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
    address: valibot.StringSchema<string>;
    type: valibot.LiteralSchema<"persona", "persona">;
}, undefined, {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "persona";
}>;
type SignedChallengeAccount = Output<typeof SignedChallengeAccount>;
declare const SignedChallengeAccount: valibot.ObjectSchema<{
    challenge: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
    address: valibot.StringSchema<string>;
    type: valibot.LiteralSchema<"account", "account">;
}, undefined, {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "account";
}>;
type SignedChallenge = Output<typeof SignedChallenge>;
declare const SignedChallenge: valibot.VariantSchema<"type", [valibot.ObjectSchema<{
    challenge: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
    address: valibot.StringSchema<string>;
    type: valibot.LiteralSchema<"persona", "persona">;
}, undefined, {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "persona";
}>, valibot.ObjectSchema<{
    challenge: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
    address: valibot.StringSchema<string>;
    type: valibot.LiteralSchema<"account", "account">;
}, undefined, {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "account";
}>], {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "persona";
} | {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "account";
}>;
declare const WalletDataPersonaDataFullName: valibot.ObjectSchema<{
    entry: valibot.LiteralSchema<"fullName", "fullName">;
    fields: valibot.ObjectSchema<{
        variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
        familyName: valibot.StringSchema<string>;
        nickname: valibot.StringSchema<string>;
        givenNames: valibot.StringSchema<string>;
    }, undefined, {
        variant: "western" | "eastern";
        familyName: string;
        nickname: string;
        givenNames: string;
    }>;
}, undefined, {
    entry: "fullName";
    fields: {
        variant: "western" | "eastern";
        familyName: string;
        nickname: string;
        givenNames: string;
    };
}>;
declare const WalletDataPersonaDataEmailAddresses: valibot.ObjectSchema<{
    entry: valibot.LiteralSchema<"emailAddresses", "emailAddresses">;
    fields: valibot.ArraySchema<valibot.StringSchema<string>, string[]>;
}, undefined, {
    entry: "emailAddresses";
    fields: string[];
}>;
declare const WalletDataPersonaDataPhoneNumbersAddresses: valibot.ObjectSchema<{
    entry: valibot.LiteralSchema<"phoneNumbers", "phoneNumbers">;
    fields: valibot.ArraySchema<valibot.StringSchema<string>, string[]>;
}, undefined, {
    entry: "phoneNumbers";
    fields: string[];
}>;
type WalletDataPersonaData = Output<typeof WalletDataPersonaData>;
declare const WalletDataPersonaData: valibot.VariantSchema<"entry", [valibot.ObjectSchema<{
    entry: valibot.LiteralSchema<"fullName", "fullName">;
    fields: valibot.ObjectSchema<{
        variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
        familyName: valibot.StringSchema<string>;
        nickname: valibot.StringSchema<string>;
        givenNames: valibot.StringSchema<string>;
    }, undefined, {
        variant: "western" | "eastern";
        familyName: string;
        nickname: string;
        givenNames: string;
    }>;
}, undefined, {
    entry: "fullName";
    fields: {
        variant: "western" | "eastern";
        familyName: string;
        nickname: string;
        givenNames: string;
    };
}>, valibot.ObjectSchema<{
    entry: valibot.LiteralSchema<"emailAddresses", "emailAddresses">;
    fields: valibot.ArraySchema<valibot.StringSchema<string>, string[]>;
}, undefined, {
    entry: "emailAddresses";
    fields: string[];
}>, valibot.ObjectSchema<{
    entry: valibot.LiteralSchema<"phoneNumbers", "phoneNumbers">;
    fields: valibot.ArraySchema<valibot.StringSchema<string>, string[]>;
}, undefined, {
    entry: "phoneNumbers";
    fields: string[];
}>], {
    entry: "fullName";
    fields: {
        variant: "western" | "eastern";
        familyName: string;
        nickname: string;
        givenNames: string;
    };
} | {
    entry: "emailAddresses";
    fields: string[];
} | {
    entry: "phoneNumbers";
    fields: string[];
}>;
type WalletData = Output<typeof WalletData>;
declare const WalletData: valibot.ObjectSchema<{
    accounts: valibot.ArraySchema<valibot.ObjectSchema<{
        address: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
        appearanceId: valibot.NumberSchema<number>;
    }, undefined, {
        address: string;
        label: string;
        appearanceId: number;
    }>, {
        address: string;
        label: string;
        appearanceId: number;
    }[]>;
    personaData: valibot.ArraySchema<valibot.VariantSchema<"entry", [valibot.ObjectSchema<{
        entry: valibot.LiteralSchema<"fullName", "fullName">;
        fields: valibot.ObjectSchema<{
            variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
            familyName: valibot.StringSchema<string>;
            nickname: valibot.StringSchema<string>;
            givenNames: valibot.StringSchema<string>;
        }, undefined, {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        }>;
    }, undefined, {
        entry: "fullName";
        fields: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        };
    }>, valibot.ObjectSchema<{
        entry: valibot.LiteralSchema<"emailAddresses", "emailAddresses">;
        fields: valibot.ArraySchema<valibot.StringSchema<string>, string[]>;
    }, undefined, {
        entry: "emailAddresses";
        fields: string[];
    }>, valibot.ObjectSchema<{
        entry: valibot.LiteralSchema<"phoneNumbers", "phoneNumbers">;
        fields: valibot.ArraySchema<valibot.StringSchema<string>, string[]>;
    }, undefined, {
        entry: "phoneNumbers";
        fields: string[];
    }>], {
        entry: "fullName";
        fields: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        };
    } | {
        entry: "emailAddresses";
        fields: string[];
    } | {
        entry: "phoneNumbers";
        fields: string[];
    }>, ({
        entry: "fullName";
        fields: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        };
    } | {
        entry: "emailAddresses";
        fields: string[];
    } | {
        entry: "phoneNumbers";
        fields: string[];
    })[]>;
    persona: valibot.OptionalSchema<valibot.ObjectSchema<{
        identityAddress: valibot.StringSchema<string>;
        label: valibot.StringSchema<string>;
    }, undefined, {
        label: string;
        identityAddress: string;
    }>, undefined, {
        label: string;
        identityAddress: string;
    } | undefined>;
    proofs: valibot.ArraySchema<valibot.VariantSchema<"type", [valibot.ObjectSchema<{
        challenge: valibot.StringSchema<string>;
        proof: valibot.ObjectSchema<{
            publicKey: valibot.StringSchema<string>;
            signature: valibot.StringSchema<string>;
            curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
        }, undefined, {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        }>;
        address: valibot.StringSchema<string>;
        type: valibot.LiteralSchema<"persona", "persona">;
    }, undefined, {
        address: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        type: "persona";
    }>, valibot.ObjectSchema<{
        challenge: valibot.StringSchema<string>;
        proof: valibot.ObjectSchema<{
            publicKey: valibot.StringSchema<string>;
            signature: valibot.StringSchema<string>;
            curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
        }, undefined, {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        }>;
        address: valibot.StringSchema<string>;
        type: valibot.LiteralSchema<"account", "account">;
    }, undefined, {
        address: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        type: "account";
    }>], {
        address: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        type: "persona";
    } | {
        address: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        type: "account";
    }>, ({
        address: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        type: "persona";
    } | {
        address: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        type: "account";
    })[]>;
}, undefined, {
    accounts: {
        address: string;
        label: string;
        appearanceId: number;
    }[];
    proofs: ({
        address: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        type: "persona";
    } | {
        address: string;
        proof: {
            publicKey: string;
            signature: string;
            curve: "curve25519" | "secp256k1";
        };
        challenge: string;
        type: "account";
    })[];
    personaData: ({
        entry: "fullName";
        fields: {
            variant: "western" | "eastern";
            familyName: string;
            nickname: string;
            givenNames: string;
        };
    } | {
        entry: "emailAddresses";
        fields: string[];
    } | {
        entry: "phoneNumbers";
        fields: string[];
    })[];
    persona?: {
        label: string;
        identityAddress: string;
    } | undefined;
}>;
type SharedData = Output<typeof SharedData>;
declare const SharedData: valibot.ObjectSchema<{
    persona: valibot.OptionalSchema<valibot.ObjectSchema<{
        proof: valibot.BooleanSchema<boolean>;
    }, undefined, {
        proof: boolean;
    }>, undefined, {
        proof: boolean;
    } | undefined>;
    ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        numberOfAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        proof: valibot.BooleanSchema<boolean>;
    }, undefined, {
        proof: boolean;
        numberOfAccounts?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        proof: boolean;
        numberOfAccounts?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
    ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
    }, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    }>, undefined, {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined>;
}, undefined, {
    persona?: {
        proof: boolean;
    } | undefined;
    ongoingAccounts?: {
        proof: boolean;
        numberOfAccounts?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
    ongoingPersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}>;
type RdtState = Output<typeof RdtState>;
declare const RdtState: valibot.ObjectSchema<{
    loggedInTimestamp: valibot.StringSchema<string>;
    walletData: valibot.ObjectSchema<{
        accounts: valibot.ArraySchema<valibot.ObjectSchema<{
            address: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
            appearanceId: valibot.NumberSchema<number>;
        }, undefined, {
            address: string;
            label: string;
            appearanceId: number;
        }>, {
            address: string;
            label: string;
            appearanceId: number;
        }[]>;
        personaData: valibot.ArraySchema<valibot.VariantSchema<"entry", [valibot.ObjectSchema<{
            entry: valibot.LiteralSchema<"fullName", "fullName">;
            fields: valibot.ObjectSchema<{
                variant: valibot.UnionSchema<(valibot.LiteralSchema<"eastern", "eastern"> | valibot.LiteralSchema<"western", "western">)[], "western" | "eastern">;
                familyName: valibot.StringSchema<string>;
                nickname: valibot.StringSchema<string>;
                givenNames: valibot.StringSchema<string>;
            }, undefined, {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            }>;
        }, undefined, {
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        }>, valibot.ObjectSchema<{
            entry: valibot.LiteralSchema<"emailAddresses", "emailAddresses">;
            fields: valibot.ArraySchema<valibot.StringSchema<string>, string[]>;
        }, undefined, {
            entry: "emailAddresses";
            fields: string[];
        }>, valibot.ObjectSchema<{
            entry: valibot.LiteralSchema<"phoneNumbers", "phoneNumbers">;
            fields: valibot.ArraySchema<valibot.StringSchema<string>, string[]>;
        }, undefined, {
            entry: "phoneNumbers";
            fields: string[];
        }>], {
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        }>, ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[]>;
        persona: valibot.OptionalSchema<valibot.ObjectSchema<{
            identityAddress: valibot.StringSchema<string>;
            label: valibot.StringSchema<string>;
        }, undefined, {
            label: string;
            identityAddress: string;
        }>, undefined, {
            label: string;
            identityAddress: string;
        } | undefined>;
        proofs: valibot.ArraySchema<valibot.VariantSchema<"type", [valibot.ObjectSchema<{
            challenge: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
            address: valibot.StringSchema<string>;
            type: valibot.LiteralSchema<"persona", "persona">;
        }, undefined, {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "persona";
        }>, valibot.ObjectSchema<{
            challenge: valibot.StringSchema<string>;
            proof: valibot.ObjectSchema<{
                publicKey: valibot.StringSchema<string>;
                signature: valibot.StringSchema<string>;
                curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
            }, undefined, {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            }>;
            address: valibot.StringSchema<string>;
            type: valibot.LiteralSchema<"account", "account">;
        }, undefined, {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "account";
        }>], {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "persona";
        } | {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "account";
        }>, ({
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "persona";
        } | {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "account";
        })[]>;
    }, undefined, {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        proofs: ({
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "persona";
        } | {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "account";
        })[];
        personaData: ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[];
        persona?: {
            label: string;
            identityAddress: string;
        } | undefined;
    }>;
    sharedData: valibot.ObjectSchema<{
        persona: valibot.OptionalSchema<valibot.ObjectSchema<{
            proof: valibot.BooleanSchema<boolean>;
        }, undefined, {
            proof: boolean;
        }>, undefined, {
            proof: boolean;
        } | undefined>;
        ongoingAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
            numberOfAccounts: valibot.OptionalSchema<valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined>;
            proof: valibot.BooleanSchema<boolean>;
        }, undefined, {
            proof: boolean;
            numberOfAccounts?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        }>, undefined, {
            proof: boolean;
            numberOfAccounts?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined>;
        ongoingPersonaData: valibot.OptionalSchema<valibot.ObjectSchema<{
            isRequestingName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
            numberOfRequestedEmailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined>;
            numberOfRequestedPhoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
                quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
                quantity: valibot.NumberSchema<number>;
            }, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            }>, undefined, {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined>;
        }, undefined, {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        }>, undefined, {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined>;
    }, undefined, {
        persona?: {
            proof: boolean;
        } | undefined;
        ongoingAccounts?: {
            proof: boolean;
            numberOfAccounts?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
        ongoingPersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    }>;
}, undefined, {
    loggedInTimestamp: string;
    walletData: {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        proofs: ({
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "persona";
        } | {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "account";
        })[];
        personaData: ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[];
        persona?: {
            label: string;
            identityAddress: string;
        } | undefined;
    };
    sharedData: {
        persona?: {
            proof: boolean;
        } | undefined;
        ongoingAccounts?: {
            proof: boolean;
            numberOfAccounts?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
        ongoingPersonaData?: {
            isRequestingName?: boolean | undefined;
            numberOfRequestedEmailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            numberOfRequestedPhoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
        } | undefined;
    };
}>;
declare const walletDataDefault: {
    accounts: never[];
    personaData: never[];
    proofs: never[];
    persona: undefined;
};

declare const canDataRequestBeResolvedByRdtState: (dataRequest: WalletUnauthorizedRequestItems | WalletAuthorizedRequestItems, state: RdtState) => boolean;

type NetworkId = number;
type PartitionKey = 'sessions' | 'identities' | 'requests' | 'state' | 'connectButton' | 'walletResponses' | 'connectorExtension';
type dAppDefinitionAddress = string;
type StorageChange<T> = {
    key: string;
    partition: string;
    newValue: Record<string, T> | undefined;
    oldValue: Record<string, T> | undefined;
};
type StorageModule<T extends object = any> = ReturnType<typeof LocalStorageModule<T>>;
declare const LocalStorageModule: <T extends object = any>(key: `rdt:${dAppDefinitionAddress}:${NetworkId}`, partitionKey?: PartitionKey) => {
    getItems: () => ResultAsync<Record<string, T>, Error>;
    getItemById: (id: string) => ResultAsync<T | undefined, Error>;
    removeItemById: (id: string) => ResultAsync<void, Error>;
    patchItem: (id: string, patch: Partial<T>) => ResultAsync<void, Error>;
    setItems: (item: Record<string, T>) => ResultAsync<void, Error>;
    getItemList: () => ResultAsync<T[], Error>;
    getPartition: (partitionKey: PartitionKey) => any;
    setState: (newValue: T) => ResultAsync<void, Error>;
    getState: () => ResultAsync<T | undefined, Error>;
    patchState: (newValue: Partial<T>) => ResultAsync<void, {
        reason: string;
    }>;
    clear: () => ResultAsync<unknown, Error>;
    storage$: rxjs.Observable<StorageChange<T>>;
};

type StateModule = ReturnType<typeof StateModule>;
declare const StateModule: (input: {
    logger?: Logger;
    providers: {
        storageModule: StorageModule<RdtState>;
    };
}) => {
    setState: (state: RdtState) => neverthrow.ResultAsync<void, Error>;
    patchState: (state: Partial<RdtState>) => neverthrow.ResultAsync<void, Error>;
    getState: () => neverthrow.ResultAsync<{
        loggedInTimestamp: string;
        walletData: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            proofs: ({
                address: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
                challenge: string;
                type: "persona";
            } | {
                address: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
                challenge: string;
                type: "account";
            })[];
            personaData: ({
                entry: "fullName";
                fields: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                };
            } | {
                entry: "emailAddresses";
                fields: string[];
            } | {
                entry: "phoneNumbers";
                fields: string[];
            })[];
            persona?: {
                label: string;
                identityAddress: string;
            } | undefined;
        };
        sharedData: {
            persona?: {
                proof: boolean;
            } | undefined;
            ongoingAccounts?: {
                proof: boolean;
                numberOfAccounts?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        };
    } | {
        walletData: {
            accounts: never[];
            personaData: never[];
            proofs: never[];
            persona: undefined;
        };
        loggedInTimestamp: string;
        sharedData: {};
    }, never>;
    walletData$: rxjs.Observable<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        proofs: ({
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "persona";
        } | {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "account";
        })[];
        personaData: ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[];
        persona?: {
            label: string;
            identityAddress: string;
        } | undefined;
    }>;
    emitWalletData: () => void;
    getWalletData: () => {
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        proofs: ({
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "persona";
        } | {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "account";
        })[];
        personaData: ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[];
        persona?: {
            label: string;
            identityAddress: string;
        } | undefined;
    } | undefined;
    reset: () => neverthrow.ResultAsync<void, Error>;
    storage$: rxjs.Observable<StorageChange<{
        loggedInTimestamp: string;
        walletData: {
            accounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
            proofs: ({
                address: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
                challenge: string;
                type: "persona";
            } | {
                address: string;
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
                challenge: string;
                type: "account";
            })[];
            personaData: ({
                entry: "fullName";
                fields: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                };
            } | {
                entry: "emailAddresses";
                fields: string[];
            } | {
                entry: "phoneNumbers";
                fields: string[];
            })[];
            persona?: {
                label: string;
                identityAddress: string;
            } | undefined;
        };
        sharedData: {
            persona?: {
                proof: boolean;
            } | undefined;
            ongoingAccounts?: {
                proof: boolean;
                numberOfAccounts?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        };
    }>>;
    destroy: () => void;
};

declare const toWalletRequest: ({ dataRequestState, isConnect, challenge, oneTime, walletData, }: {
    dataRequestState: DataRequestState;
    isConnect: boolean;
    oneTime: boolean;
    challenge?: string;
    walletData: WalletData;
}) => neverthrow.Result<{
    discriminator: "unauthorizedRequest";
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
} | {
    discriminator: "authorizedRequest";
    auth: {
        identityAddress: string;
        discriminator: "usePersona";
    } | {
        discriminator: "loginWithoutChallenge";
    } | {
        challenge: string;
        discriminator: "loginWithChallenge";
    };
    oneTimeAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    oneTimePersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
    reset?: {
        accounts: boolean;
        personaData: boolean;
    } | undefined;
    ongoingAccounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        challenge?: string | undefined;
    } | undefined;
    ongoingPersonaData?: {
        isRequestingName?: boolean | undefined;
        numberOfRequestedEmailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        numberOfRequestedPhoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
    } | undefined;
}, never>;

type TransformRdtDataRequestToWalletRequestInput = Output<typeof TransformRdtDataRequestToWalletRequestInput>;
declare const TransformRdtDataRequestToWalletRequestInput: valibot.ObjectSchema<{
    accounts: valibot.OptionalSchema<valibot.ObjectSchema<{
        numberOfAccounts: valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>;
        reset: valibot.BooleanSchema<boolean>;
        oneTime: valibot.BooleanSchema<boolean>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
    }, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        reset: boolean;
        oneTime: boolean;
        challenge?: string | undefined;
    }>, undefined, {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        reset: boolean;
        oneTime: boolean;
        challenge?: string | undefined;
    } | undefined>;
    personaData: valibot.OptionalSchema<valibot.ObjectSchema<{
        fullName: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
        phoneNumbers: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        emailAddresses: valibot.OptionalSchema<valibot.ObjectSchema<{
            quantifier: valibot.UnionSchema<(valibot.LiteralSchema<"exactly", "exactly"> | valibot.LiteralSchema<"atLeast", "atLeast">)[], "exactly" | "atLeast">;
            quantity: valibot.NumberSchema<number>;
        }, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        }>, undefined, {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined>;
        reset: valibot.BooleanSchema<boolean>;
        oneTime: valibot.OptionalSchema<valibot.BooleanSchema<boolean>, undefined, boolean | undefined>;
    }, undefined, {
        reset: boolean;
        emailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        phoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        fullName?: boolean | undefined;
        oneTime?: boolean | undefined;
    }>, undefined, {
        reset: boolean;
        emailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        phoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        fullName?: boolean | undefined;
        oneTime?: boolean | undefined;
    } | undefined>;
    persona: valibot.OptionalSchema<valibot.ObjectSchema<{
        identityAddress: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        label: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
        challenge: valibot.OptionalSchema<valibot.StringSchema<string>, undefined, string | undefined>;
    }, undefined, {
        label?: string | undefined;
        identityAddress?: string | undefined;
        challenge?: string | undefined;
    }>, undefined, {
        label?: string | undefined;
        identityAddress?: string | undefined;
        challenge?: string | undefined;
    } | undefined>;
}, undefined, {
    accounts?: {
        numberOfAccounts: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        };
        reset: boolean;
        oneTime: boolean;
        challenge?: string | undefined;
    } | undefined;
    personaData?: {
        reset: boolean;
        emailAddresses?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        phoneNumbers?: {
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } | undefined;
        fullName?: boolean | undefined;
        oneTime?: boolean | undefined;
    } | undefined;
    persona?: {
        label?: string | undefined;
        identityAddress?: string | undefined;
        challenge?: string | undefined;
    } | undefined;
}>;
declare const transformRdtDataRequestToWalletRequest: (isConnect: boolean, input: TransformRdtDataRequestToWalletRequestInput) => Result<WalletUnauthorizedRequestItems | WalletAuthorizedRequestItems, never>;

declare const transformWalletRequestToSharedData: (walletInteraction: WalletInteraction, sharedData: SharedData) => SharedData;
declare const transformSharedDataToDataRequestState: (sharedData: SharedData) => DataRequestState;

type WalletDataRequestResponse = WalletAuthorizedRequestResponseItems | WalletUnauthorizedRequestResponseItems;
declare const transformWalletResponseToRdtWalletData: (response: WalletDataRequestResponse) => ResultAsync<WalletData, never>;

declare const transformWalletDataToConnectButton: (walletData: WalletData) => {
    accounts: {
        address: string;
        label: string;
        appearanceId: number;
    }[];
    personaLabel: string;
    connected: boolean;
    personaData: {
        value: string;
        field: string;
    }[];
};

type DataRequestStateModule = ReturnType<typeof DataRequestStateModule>;
declare const DataRequestStateModule: (initialState: DataRequestState) => {
    reset: () => void;
    setState: (...items: DataRequestBuilderItem[]) => void;
    getState: () => Partial<{
        accounts: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            reset?: boolean | undefined;
            withProof?: boolean | undefined;
        };
    } & {
        personaData: {
            emailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            phoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            reset?: boolean | undefined;
            fullName?: boolean | undefined;
        };
    } & {
        persona: {
            withProof?: boolean | undefined;
        };
    }>;
    patchState: (...items: DataRequestBuilderItem[]) => void;
    removeState: (...keys: (keyof DataRequestState)[]) => void;
    toDataRequestState: (...items: unknown[]) => DataRequestState;
    state$: rxjs.Observable<Partial<{
        accounts: {
            numberOfAccounts: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            };
            reset?: boolean | undefined;
            withProof?: boolean | undefined;
        };
    } & {
        personaData: {
            emailAddresses?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            phoneNumbers?: {
                quantifier: "exactly" | "atLeast";
                quantity: number;
            } | undefined;
            reset?: boolean | undefined;
            fullName?: boolean | undefined;
        };
    } & {
        persona: {
            withProof?: boolean | undefined;
        };
    }>>;
};

declare const IdentityKind: {
    readonly dApp: "dApp";
};
type IdentityKind = (typeof IdentityKind)[keyof typeof IdentityKind];
type IdentitySecret = {
    secret: string;
    createdAt: number;
};
type IdentityStore = {
    [IdentityKind.dApp]: IdentitySecret;
};
type IdentityModule = ReturnType<typeof IdentityModule>;
declare const IdentityModule: (input: {
    logger?: Logger;
    dAppDefinitionAddress: string;
    providers: {
        storageModule: StorageModule<IdentitySecret>;
        KeyPairModule: KeyPairProvider;
    };
}) => {
    get: (kind: IdentityKind) => ResultAsync<{
        getPrivateKey: () => string;
        x25519: {
            getPublicKey: () => string;
            calculateSharedSecret: (publicKeyHex: string, dAppDefinitionAddress: string) => neverthrow.Result<string, Error>;
        };
        ed25519: {
            getPublicKey: () => string;
            sign: (messageHex: string) => neverthrow.Result<string, Error>;
        };
    }, {
        reason: string;
        jsError: Error;
    }>;
    deriveSharedSecret: (kind: IdentityKind, publicKey: string) => ResultAsync<string, {
        reason: string;
    } | {
        reason: string;
    }>;
    createSignature: ({ kind, interactionId, dAppDefinitionAddress, origin, }: {
        kind: IdentityKind;
        interactionId: string;
        dAppDefinitionAddress: string;
        origin: string;
    }) => ResultAsync<{
        signature: string;
        publicKey: string;
    }, {
        reason: string;
        jsError: Error;
    }>;
};

type RequestItemModuleInput = {
    logger?: Logger;
    providers: {
        storageModule: StorageModule<RequestItem>;
    };
};
type RequestItemModule = ReturnType<typeof RequestItemModule>;
declare const RequestItemModule: (input: RequestItemModuleInput) => {
    add: (value: {
        type: RequestItem['type'];
        walletInteraction: WalletInteraction;
        isOneTimeRequest: boolean;
    }) => ResultAsync<RequestItem, Error>;
    cancel: (id: string) => ResultAsync<void, Error>;
    updateStatus: ({ id, status, error, transactionIntentHash, }: {
        id: string;
        status: RequestStatusTypes;
        error?: string;
        transactionIntentHash?: string;
    }) => ResultAsync<void, {
        reason: string;
    }>;
    patch: (id: string, partialValue: Partial<RequestItem>) => ResultAsync<void, Error>;
    getById: (id: string) => ResultAsync<RequestItem | undefined, Error>;
    getPending: () => ResultAsync<RequestItem[], Error>;
    requests$: rxjs.Observable<RequestItem[]>;
    clear: () => ResultAsync<unknown, Error>;
    destroy: () => void;
};

type Session = {
    sessionId: string;
    createdAt: number;
};
type SessionModule = ReturnType<typeof SessionModule>;
declare const SessionModule: (input: {
    providers: {
        storageModule: StorageModule<Session>;
    };
}) => {
    getCurrentSession: () => ResultAsync<Session, {
        reason: string;
        jsError: Error;
    }>;
    getSession: () => ResultAsync<Session | undefined, {
        reason: string;
        jsError: Error;
    }>;
    store: StorageModule<Session>;
    getSessionById: (sessionId: string) => ResultAsync<Session | undefined, {
        reason: string;
        jsError: Error;
    }>;
    patchSession: (sessionId: string, value: Partial<Session>) => ResultAsync<void, {
        reason: string;
        jsError: Error;
    }>;
};

type ConnectorExtensionSubjects = ReturnType<typeof ConnectorExtensionSubjects>;
declare const ConnectorExtensionSubjects: () => {
    outgoingMessageSubject: Subject<{
        interactionId: string;
        metadata: {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        };
        items: {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                identityAddress: string;
                discriminator: "usePersona";
            } | {
                discriminator: "loginWithoutChallenge";
            } | {
                challenge: string;
                discriminator: "loginWithChallenge";
            };
            oneTimeAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            oneTimePersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
            reset?: {
                accounts: boolean;
                personaData: boolean;
            } | undefined;
            ongoingAccounts?: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                challenge?: string | undefined;
            } | undefined;
            ongoingPersonaData?: {
                isRequestingName?: boolean | undefined;
                numberOfRequestedEmailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                numberOfRequestedPhoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
            } | undefined;
        } | {
            discriminator: "transaction";
            send: {
                transactionManifest: string;
                version: number;
                message?: string | undefined;
                blobs?: string[] | undefined;
            };
        } | {
            discriminator: "cancelRequest";
        };
    } | {
        discriminator: "extensionStatus";
        interactionId: string;
    } | {
        discriminator: "openPopup";
        interactionId: string;
    } | {
        discriminator: "walletInteraction";
        interactionId: string;
        interaction: {
            interactionId: string;
            metadata: {
                version: 2;
                networkId: number;
                dAppDefinitionAddress: string;
                origin: string;
            };
            items: {
                discriminator: "unauthorizedRequest";
                oneTimeAccounts?: {
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                    challenge?: string | undefined;
                } | undefined;
                oneTimePersonaData?: {
                    isRequestingName?: boolean | undefined;
                    numberOfRequestedEmailAddresses?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                    numberOfRequestedPhoneNumbers?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                } | undefined;
            } | {
                discriminator: "authorizedRequest";
                auth: {
                    identityAddress: string;
                    discriminator: "usePersona";
                } | {
                    discriminator: "loginWithoutChallenge";
                } | {
                    challenge: string;
                    discriminator: "loginWithChallenge";
                };
                oneTimeAccounts?: {
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                    challenge?: string | undefined;
                } | undefined;
                oneTimePersonaData?: {
                    isRequestingName?: boolean | undefined;
                    numberOfRequestedEmailAddresses?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                    numberOfRequestedPhoneNumbers?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                } | undefined;
                reset?: {
                    accounts: boolean;
                    personaData: boolean;
                } | undefined;
                ongoingAccounts?: {
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                    challenge?: string | undefined;
                } | undefined;
                ongoingPersonaData?: {
                    isRequestingName?: boolean | undefined;
                    numberOfRequestedEmailAddresses?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                    numberOfRequestedPhoneNumbers?: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    } | undefined;
                } | undefined;
            } | {
                discriminator: "transaction";
                send: {
                    transactionManifest: string;
                    version: number;
                    message?: string | undefined;
                    blobs?: string[] | undefined;
                };
            } | {
                discriminator: "cancelRequest";
            };
        };
        sessionId?: string | undefined;
    } | {
        discriminator: "cancelWalletInteraction";
        interactionId: string;
        metadata: {
            version: 2;
            networkId: number;
            dAppDefinitionAddress: string;
            origin: string;
        };
    }>;
    incomingMessageSubject: Subject<{
        discriminator: "success";
        interactionId: string;
        items: {
            discriminator: "transaction";
            send: {
                transactionIntentHash: string;
            };
        } | {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        publicKey: string;
                        signature: string;
                        curve: "curve25519" | "secp256k1";
                    };
                }[] | undefined;
            } | undefined;
            oneTimePersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "loginWithoutChallenge";
            } | {
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
                challenge: string;
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "loginWithChallenge";
            } | {
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "usePersona";
            };
            oneTimeAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        publicKey: string;
                        signature: string;
                        curve: "curve25519" | "secp256k1";
                    };
                }[] | undefined;
            } | undefined;
            oneTimePersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
            ongoingAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        publicKey: string;
                        signature: string;
                        curve: "curve25519" | "secp256k1";
                    };
                }[] | undefined;
            } | undefined;
            ongoingPersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
        };
    } | {
        error: string;
        discriminator: "failure";
        interactionId: string;
        message?: string | undefined;
    } | {
        interactionId: string;
        eventType: "extensionStatus";
        isWalletLinked: boolean;
        isExtensionAvailable: boolean;
        canHandleSessions?: boolean | undefined;
    } | {
        interactionId: string;
        eventType: "extensionStatus" | "receivedByExtension" | "receivedByWallet" | "requestCancelSuccess" | "requestCancelFail";
    }>;
    responseSubject: Subject<{
        discriminator: "success";
        interactionId: string;
        items: {
            discriminator: "transaction";
            send: {
                transactionIntentHash: string;
            };
        } | {
            discriminator: "unauthorizedRequest";
            oneTimeAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        publicKey: string;
                        signature: string;
                        curve: "curve25519" | "secp256k1";
                    };
                }[] | undefined;
            } | undefined;
            oneTimePersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
        } | {
            discriminator: "authorizedRequest";
            auth: {
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "loginWithoutChallenge";
            } | {
                proof: {
                    publicKey: string;
                    signature: string;
                    curve: "curve25519" | "secp256k1";
                };
                challenge: string;
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "loginWithChallenge";
            } | {
                persona: {
                    label: string;
                    identityAddress: string;
                };
                discriminator: "usePersona";
            };
            oneTimeAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        publicKey: string;
                        signature: string;
                        curve: "curve25519" | "secp256k1";
                    };
                }[] | undefined;
            } | undefined;
            oneTimePersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
            ongoingAccounts?: {
                accounts: {
                    address: string;
                    label: string;
                    appearanceId: number;
                }[];
                challenge?: string | undefined;
                proofs?: {
                    accountAddress: string;
                    proof: {
                        publicKey: string;
                        signature: string;
                        curve: "curve25519" | "secp256k1";
                    };
                }[] | undefined;
            } | undefined;
            ongoingPersonaData?: {
                name?: {
                    variant: "western" | "eastern";
                    familyName: string;
                    nickname: string;
                    givenNames: string;
                } | undefined;
                emailAddresses?: string[] | undefined;
                phoneNumbers?: string[] | undefined;
            } | undefined;
        };
    } | {
        error: string;
        discriminator: "failure";
        interactionId: string;
        message?: string | undefined;
    }>;
    messageLifeCycleEventSubject: Subject<{
        interactionId: string;
        eventType: "extensionStatus" | "receivedByExtension" | "receivedByWallet" | "requestCancelSuccess" | "requestCancelFail";
    }>;
};

type ConnectorExtensionModule = ReturnType<typeof ConnectorExtensionModule>;
declare const ConnectorExtensionModule: (input: {
    subjects?: ConnectorExtensionSubjects;
    logger?: Logger;
    extensionDetectionTime?: number;
    providers: {
        requestItemModule: RequestItemModule;
        storageModule: StorageModule<{
            sessionId?: string;
        }>;
    };
}) => {
    id: "connector-extension";
    isSupported: () => boolean;
    send: (walletInteraction: WalletInteraction, callbackFns: Partial<CallbackFns>) => ResultAsync<unknown, SdkError>;
    isAvailable$: rxjs.Observable<boolean>;
    isLinked$: rxjs.Observable<boolean>;
    showQrCode: () => void;
    disconnect: () => void;
    destroy: () => void;
};

type DeepLinkModule = ReturnType<typeof DeepLinkModule>;
declare const DeepLinkModule: (input: {
    logger?: Logger;
    walletUrl: string;
}) => {
    deepLinkToWallet: (values: Record<string, string>) => ResultAsync<undefined, SdkError>;
};

type SealedBoxProps = {
    ciphertext: Buffer;
    iv: Buffer;
    authTag: Buffer;
    combined: Buffer;
    ciphertextAndAuthTag: Buffer;
};

type EncryptionModule = ReturnType<typeof EncryptionModule>;
declare const EncryptionModule: () => {
    encrypt: (data: Buffer, encryptionKey: Buffer, iv?: Buffer) => ResultAsync<Omit<SealedBoxProps, 'ciphertextAndAuthTag' | 'authTag'>, Error>;
    decrypt: (data: Buffer, encryptionKey: Buffer, iv: Buffer) => ResultAsync<Buffer, Error>;
    createIV: () => Buffer;
};

type RadixConnectRelayModule = ReturnType<typeof RadixConnectRelayModule>;
declare const RadixConnectRelayModule: (input: {
    baseUrl: string;
    logger?: Logger;
    walletUrl: string;
    dAppDefinitionAddress: string;
    providers: {
        requestItemModule: RequestItemModule;
        storageModule: StorageModule;
        encryptionModule?: EncryptionModule;
        identityModule?: IdentityModule;
        sessionModule?: SessionModule;
        deepLinkModule?: DeepLinkModule;
    };
}) => TransportProvider;

type WalletRequestSdkInput = {
    networkId: number;
    dAppDefinitionAddress: string;
    logger?: Logger;
    origin?: string;
    requestInterceptor?: (walletInteraction: WalletInteraction) => Promise<WalletInteraction>;
    providers: {
        transports: TransportProvider[];
    };
};
type WalletRequestSdk = ReturnType<typeof WalletRequestSdk>;
declare const WalletRequestSdk: (input: WalletRequestSdkInput) => {
    request: ({ interactionId, items, }: Pick<WalletInteraction, 'items'> & {
        interactionId?: string;
    }, callbackFns?: Partial<CallbackFns>) => ResultAsync<WalletInteractionResponse, SdkError>;
    sendTransaction: ({ interactionId, items, }: {
        interactionId?: string;
        items: WalletInteraction['items'];
    }, callbackFns?: Partial<CallbackFns>) => ResultAsync<WalletInteractionResponse, SdkError>;
    createWalletInteraction: (items: WalletInteractionItems, interactionId?: string) => WalletInteraction;
    getTransport: (interactionId: string) => Result<TransportProvider, SdkError>;
};

declare const generateGatewayApiConfig: ({ networkId, dAppDefinitionAddress, gatewayBaseUrl, applicationName, applicationVersion, }: {
    networkId: number;
    dAppDefinitionAddress: string;
    gatewayBaseUrl?: string;
    applicationName?: string;
    applicationVersion?: string;
}) => {
    basePath: string;
    applicationName: string;
    applicationVersion: string;
    applicationDappDefinitionAddress: string;
};

type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus];
declare const TransactionStatus: {
    readonly Unknown: "Unknown";
    readonly CommittedSuccess: "CommittedSuccess";
    readonly CommittedFailure: "CommittedFailure";
    readonly Pending: "Pending";
    readonly Rejected: "Rejected";
};
type MetadataStringValue = {
    type: 'String';
    value: string;
};
type MetadataTypedValue = {
    type: 'String';
} & MetadataStringValue;
type EntityMetadataItemValue = {
    typed: MetadataTypedValue;
};
type EntityMetadataItem = {
    key: string;
    value: EntityMetadataItemValue;
    is_locked: boolean;
    last_updated_at_state_version: number;
};
type TransactionStatusResponse = {
    status: TransactionStatus;
};
declare const RadixNetwork: {
    readonly Mainnet: 1;
    readonly Stokenet: 2;
    readonly Gilganet: 32;
    readonly Enkinet: 33;
    readonly Hammunet: 34;
    readonly Nergalnet: 35;
    readonly Mardunet: 36;
    readonly Dumunet: 37;
};
type NetworkConfig = {
    networkName: string;
    networkId: (typeof RadixNetwork)[keyof typeof RadixNetwork];
    gatewayUrl: string;
    dashboardUrl: string;
};
declare const RadixNetworkConfig: Record<string, NetworkConfig>;
declare const RadixNetworkConfigById: Record<number, NetworkConfig>;

type GatewayApiService = ReturnType<typeof GatewayApiService>;
declare const GatewayApiService: ({ basePath, applicationName, applicationVersion, applicationDappDefinitionAddress, }: GatewayApiClientConfig) => {
    getTransactionStatus: (transactionIntentHash: string) => neverthrow.ResultAsync<{
        status: TransactionStatus;
    }, {
        status: number;
        error?: Error | undefined;
        reason: string;
        data?: unknown;
    }>;
    getEntityMetadataPage: (address: string) => neverthrow.ResultAsync<{
        items: EntityMetadataItem[];
    }, {
        status: number;
        error?: Error | undefined;
        reason: string;
        data?: unknown;
    }>;
};

type GatewayModule = ReturnType<typeof GatewayModule>;
declare const GatewayModule: (input: {
    clientConfig: GatewayApiClientConfig;
    logger?: Logger;
    retryConfig?: ExponentialBackoffInput;
    providers?: {
        gatewayApiService?: GatewayApiService;
    };
}) => {
    readonly pollTransactionStatus: (transactionIntentHash: string) => ResultAsync<TransactionStatusResponse, SdkError>;
    readonly gatewayApi: {
        getTransactionStatus: (transactionIntentHash: string) => ResultAsync<{
            status: TransactionStatus;
        }, {
            status: number;
            error?: Error | undefined;
            reason: string;
            data?: unknown;
        }>;
        getEntityMetadataPage: (address: string) => ResultAsync<{
            items: EntityMetadataItem[];
        }, {
            status: number;
            error?: Error | undefined;
            reason: string;
            data?: unknown;
        }>;
    };
    readonly configuration: GatewayApiClientConfig;
};

type SendTransactionInput$1 = {
    transactionManifest: string;
    version?: number;
    blobs?: string[];
    message?: string;
    onTransactionId?: (transactionId: string) => void;
};
type WalletRequestModule = ReturnType<typeof WalletRequestModule>;
declare const WalletRequestModule: (input: {
    logger?: Logger;
    origin?: string;
    networkId: number;
    useCache: boolean;
    requestInterceptor?: (input: WalletInteraction) => Promise<WalletInteraction>;
    dAppDefinitionAddress: string;
    providers: {
        stateModule: StateModule;
        storageModule: StorageModule;
        gatewayModule: GatewayModule;
        transports?: TransportProvider[];
        dataRequestStateModule?: DataRequestStateModule;
        requestItemModule?: RequestItemModule;
        walletRequestSdk?: WalletRequestSdk;
    };
}) => {
    sendRequest: (input: {
        isConnect: boolean;
        oneTime: boolean;
    }) => WalletDataRequestResult;
    sendTransaction: (value: SendTransactionInput$1) => ResultAsync<{
        transactionIntentHash: string;
        status: TransactionStatus;
    }, SdkError>;
    cancelRequest: (id: string) => void;
    ignoreTransaction: (id: string) => void;
    requestItemModule: {
        add: (value: {
            type: "loginRequest" | "dataRequest" | "sendTransaction";
            walletInteraction: {
                interactionId: string;
                metadata: {
                    version: 2;
                    networkId: number;
                    dAppDefinitionAddress: string;
                    origin: string;
                };
                items: {
                    discriminator: "unauthorizedRequest";
                    oneTimeAccounts?: {
                        numberOfAccounts: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        };
                        challenge?: string | undefined;
                    } | undefined;
                    oneTimePersonaData?: {
                        isRequestingName?: boolean | undefined;
                        numberOfRequestedEmailAddresses?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                        numberOfRequestedPhoneNumbers?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                    } | undefined;
                } | {
                    discriminator: "authorizedRequest";
                    auth: {
                        identityAddress: string;
                        discriminator: "usePersona";
                    } | {
                        discriminator: "loginWithoutChallenge";
                    } | {
                        challenge: string;
                        discriminator: "loginWithChallenge";
                    };
                    oneTimeAccounts?: {
                        numberOfAccounts: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        };
                        challenge?: string | undefined;
                    } | undefined;
                    oneTimePersonaData?: {
                        isRequestingName?: boolean | undefined;
                        numberOfRequestedEmailAddresses?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                        numberOfRequestedPhoneNumbers?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                    } | undefined;
                    reset?: {
                        accounts: boolean;
                        personaData: boolean;
                    } | undefined;
                    ongoingAccounts?: {
                        numberOfAccounts: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        };
                        challenge?: string | undefined;
                    } | undefined;
                    ongoingPersonaData?: {
                        isRequestingName?: boolean | undefined;
                        numberOfRequestedEmailAddresses?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                        numberOfRequestedPhoneNumbers?: {
                            quantifier: "exactly" | "atLeast";
                            quantity: number;
                        } | undefined;
                    } | undefined;
                } | {
                    discriminator: "transaction";
                    send: {
                        transactionManifest: string;
                        version: number;
                        message?: string | undefined;
                        blobs?: string[] | undefined;
                    };
                } | {
                    discriminator: "cancelRequest";
                };
            };
            isOneTimeRequest: boolean;
        }) => ResultAsync<radix_connect_common.RequestItem, Error>;
        cancel: (id: string) => ResultAsync<void, Error>;
        updateStatus: ({ id, status, error, transactionIntentHash, }: {
            id: string;
            status: "pending" | "success" | "fail" | "cancelled" | "ignored";
            error?: string | undefined;
            transactionIntentHash?: string | undefined;
        }) => ResultAsync<void, {
            reason: string;
        }>;
        patch: (id: string, partialValue: Partial<radix_connect_common.RequestItem>) => ResultAsync<void, Error>;
        getById: (id: string) => ResultAsync<radix_connect_common.RequestItem | undefined, Error>;
        getPending: () => ResultAsync<radix_connect_common.RequestItem[], Error>;
        requests$: rxjs.Observable<radix_connect_common.RequestItem[]>;
        clear: () => ResultAsync<unknown, Error>;
        destroy: () => void;
    };
    provideChallengeGenerator: (fn: () => Promise<string>) => void;
    provideDataRequestControl: (fn: (walletData: WalletData) => Promise<any>) => void;
    provideConnectResponseCallback: (fn: (result: AwaitedWalletDataRequestResult) => any) => void;
    sendOneTimeRequest: (...items: DataRequestBuilderItem[]) => WalletDataRequestResult;
    setRequestDataState: (...items: DataRequestBuilderItem[]) => {
        sendRequest: () => WalletDataRequestResult;
    };
    getPendingRequests: () => ResultAsync<radix_connect_common.RequestItem[], Error>;
    getTransport: () => TransportProvider | undefined;
    updateSharedAccounts: () => ResultAsync<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        proofs: ({
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "persona";
        } | {
            address: string;
            proof: {
                publicKey: string;
                signature: string;
                curve: "curve25519" | "secp256k1";
            };
            challenge: string;
            type: "account";
        })[];
        personaData: ({
            entry: "fullName";
            fields: {
                variant: "western" | "eastern";
                familyName: string;
                nickname: string;
                givenNames: string;
            };
        } | {
            entry: "emailAddresses";
            fields: string[];
        } | {
            entry: "phoneNumbers";
            fields: string[];
        })[];
        persona?: {
            label: string;
            identityAddress: string;
        } | undefined;
    }, WalletDataRequestError | {
        error: string;
        message: string;
        jsError: never;
    }>;
    dataRequestStateModule: {
        reset: () => void;
        setState: (...items: DataRequestBuilderItem[]) => void;
        getState: () => Partial<{
            accounts: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                reset?: boolean | undefined;
                withProof?: boolean | undefined;
            };
        } & {
            personaData: {
                emailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                phoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                reset?: boolean | undefined;
                fullName?: boolean | undefined;
            };
        } & {
            persona: {
                withProof?: boolean | undefined;
            };
        }>;
        patchState: (...items: DataRequestBuilderItem[]) => void;
        removeState: (...keys: ("accounts" | "personaData" | "persona")[]) => void;
        toDataRequestState: (...items: unknown[]) => Partial<{
            accounts: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                reset?: boolean | undefined;
                withProof?: boolean | undefined;
            };
        } & {
            personaData: {
                emailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                phoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                reset?: boolean | undefined;
                fullName?: boolean | undefined;
            };
        } & {
            persona: {
                withProof?: boolean | undefined;
            };
        }>;
        state$: rxjs.Observable<Partial<{
            accounts: {
                numberOfAccounts: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                };
                reset?: boolean | undefined;
                withProof?: boolean | undefined;
            };
        } & {
            personaData: {
                emailAddresses?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                phoneNumbers?: {
                    quantifier: "exactly" | "atLeast";
                    quantity: number;
                } | undefined;
                reset?: boolean | undefined;
                fullName?: boolean | undefined;
            };
        } & {
            persona: {
                withProof?: boolean | undefined;
            };
        }>>;
    };
    interactionStatusChange$: rxjs.Observable<"success" | "fail">;
    requestItems$: rxjs.Observable<radix_connect_common.RequestItem[]>;
    disconnect: () => void;
    destroy: () => void;
};

type ConnectButtonModuleInput = {
    networkId: number;
    environment?: string;
    dAppDefinitionAddress?: string;
    onConnect?: (done: (input?: {
        challenge: string;
    }) => void) => void;
    subjects?: ConnectButtonSubjects;
    logger?: Logger;
    onDisconnect?: () => void;
    explorer?: ExplorerConfig;
    providers: {
        stateModule: StateModule;
        gatewayModule: GatewayModule;
        walletRequestModule: WalletRequestModule;
        storageModule: StorageModule<{
            status: ConnectButtonStatus;
        }>;
    };
};
type ConnectButtonModule = ReturnType<typeof ConnectButtonModule>;
declare const ConnectButtonModule: (input: ConnectButtonModuleInput) => ConnectButtonModuleOutput;

declare const parseSignedChallenge: (value: SignedChallenge) => valibot.SafeParseResult<valibot.VariantSchema<"type", [valibot.ObjectSchema<{
    challenge: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
    address: valibot.StringSchema<string>;
    type: valibot.LiteralSchema<"persona", "persona">;
}, undefined, {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "persona";
}>, valibot.ObjectSchema<{
    challenge: valibot.StringSchema<string>;
    proof: valibot.ObjectSchema<{
        publicKey: valibot.StringSchema<string>;
        signature: valibot.StringSchema<string>;
        curve: valibot.UnionSchema<(valibot.LiteralSchema<"curve25519", "curve25519"> | valibot.LiteralSchema<"secp256k1", "secp256k1">)[], "curve25519" | "secp256k1">;
    }, undefined, {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    }>;
    address: valibot.StringSchema<string>;
    type: valibot.LiteralSchema<"account", "account">;
}, undefined, {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "account";
}>], {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "persona";
} | {
    address: string;
    proof: {
        publicKey: string;
        signature: string;
        curve: "curve25519" | "secp256k1";
    };
    challenge: string;
    type: "account";
}>>;

type Providers = {
    connectButtonModule: ConnectButtonModule;
    gatewayModule: GatewayModule;
    stateModule: StateModule;
    storageModule: StorageModule;
    walletRequestModule: WalletRequestModule;
};
type ExplorerConfig = {
    baseUrl: string;
    transactionPath: string;
    accountsPath: string;
};
type WalletDataRequest = Parameters<WalletRequestSdk['request']>[0];
type WalletRequest = {
    type: 'sendTransaction';
    payload: WalletInteraction;
} | {
    type: 'dataRequest';
    payload: WalletInteraction;
};
type OptionalRadixDappToolkitOptions = {
    logger: Logger;
    onDisconnect: () => void;
    explorer: ExplorerConfig;
    gatewayBaseUrl: string;
    applicationName: string;
    applicationVersion: string;
    useCache: boolean;
    providers: Partial<Providers>;
    requestInterceptor: (input: WalletInteraction) => Promise<WalletInteraction>;
    featureFlags: string[];
};
type RequiredRadixDappToolkitOptions = {
    networkId: number;
} & ({
    dAppDefinitionAddress: string;
    applicationDappDefinitionAddress?: never;
} | {
    dAppDefinitionAddress?: never;
    applicationDappDefinitionAddress: string;
});
type RadixDappToolkitOptions = Partial<OptionalRadixDappToolkitOptions> & RequiredRadixDappToolkitOptions;
type SendTransactionResult = ResultAsync<{
    transactionIntentHash: string;
    status: TransactionStatus;
}, {
    error: string;
    jsError?: unknown;
    message?: string;
    transactionIntentHash?: string;
    status?: TransactionStatus;
}>;
type SendTransactionInput = {
    transactionManifest: string;
    version?: number;
    blobs?: string[];
    message?: string;
    onTransactionId?: (transactionId: string) => void;
};
type ButtonApi = {
    setMode: (value: 'light' | 'dark') => void;
    setTheme: (value: RadixButtonTheme) => void;
    status$: Observable<RadixButtonStatus>;
};
type WalletDataRequestError = {
    error: string;
    message?: string;
    jsError?: unknown;
};
type WalletDataRequestResult = ResultAsync<WalletData, WalletDataRequestError>;
type AwaitedWalletDataRequestResult = Result<WalletData, WalletDataRequestError>;
type WalletApi = {
    getWalletData: () => WalletDataState | undefined;
    walletData$: Observable<WalletDataState>;
    provideChallengeGenerator: (fn: () => Promise<string>) => void;
    provideConnectResponseCallback: (fn: (result: AwaitedWalletDataRequestResult) => void) => void;
    dataRequestControl: (fn: (walletResponse: WalletData) => Promise<any>) => void;
    updateSharedAccounts: () => WalletDataRequestResult;
    sendTransaction: (input: SendTransactionInput) => SendTransactionResult;
    setRequestData: (...dataRequestBuilderItem: DataRequestBuilderItem[]) => void;
    sendRequest: () => WalletDataRequestResult;
    sendOneTimeRequest: (...oneTimeDataRequestBuilderItem: OneTimeDataRequestBuilderItem[]) => WalletDataRequestResult;
};
type WalletDataStateAccount = {
    address: string;
    label: string;
    appearanceId: number;
};
type WalletDataStatePersonaData = {
    entry: 'fullName';
    fields: PersonaDataName;
} | {
    entry: 'emailAddresses';
    fields: string[];
} | {
    entry: 'phoneNumbers';
    fields: string[];
};
type WalletDataState = {
    accounts: WalletDataStateAccount[];
    personaData: WalletDataStatePersonaData[];
    proofs: SignedChallenge[];
    persona?: Persona;
};
type TransportProvider = {
    id: string;
    isLinked$?: Observable<boolean>;
    isAvailable$?: Observable<boolean>;
    sessionChange$?: Observable<Session>;
    showQrCode?: () => void;
    isSupported: () => boolean;
    send: (walletInteraction: WalletInteraction, callbackFns: Partial<CallbackFns>) => ResultAsync<unknown, SdkError>;
    disconnect: () => void;
    destroy: () => void;
};
type GatewayApiClientConfig = {
    basePath: string;
    applicationName: string;
    applicationVersion: string;
    applicationDappDefinitionAddress: string;
};

type RadixDappToolkit = {
    walletApi: WalletApi;
    buttonApi: ButtonApi;
    gatewayApi: {
        clientConfig: GatewayApiClientConfig;
    };
    disconnect: () => void;
    destroy: () => void;
};
declare const RadixDappToolkit: (options: RadixDappToolkitOptions) => RadixDappToolkit;

export { Account, AccountProof, AccountsRequestItem, AccountsRequestResponseItem, type Answer, AnswerIO, AuthLoginRequestItem, AuthLoginRequestResponseItem, AuthLoginWithChallengeRequestItem, AuthLoginWithChallengeRequestResponseItem, AuthLoginWithoutChallengeRequestItem, AuthLoginWithoutChallengeRequestResponseItem, AuthRequestItem, AuthRequestResponseItem, AuthUsePersonaRequestItem, AuthUsePersonaRequestResponseItem, type AwaitedWalletDataRequestResult, type ButtonApi, type CallbackFns, CancelRequest, CancelWalletInteractionExtensionInteraction, type ConfigRequestBuilder, type Confirmation, ConnectButtonModule, type ConnectButtonModuleInput, type ConnectButtonModuleOutput, ConnectButtonStatus, ConnectButtonSubjects, ConnectorExtensionModule, ConnectorExtensionSubjects, Curve25519, DataRequestBuilder, type DataRequestBuilderItem, type DataRequestState, DataRequestStateModule, type DataTypes, DeepLinkModule, type EntityMetadataItem, type EntityMetadataItemValue, type ExplorerConfig, ExponentialBackoff, type ExponentialBackoffInput, ExtensionInteraction, type GatewayApiClientConfig, GatewayApiService, GatewayModule, type IceCandidate, IceCandidateIO, IceCandidatePayloadIO, type IceCandidates, IceCandidatesIO, IdentityKind, IdentityModule, type IdentitySecret, type IdentityStore, IncomingMessage, type InvalidMessageError, type KeyPairProvider, LocalStorageModule, Logger, LoginRequestResponseItem, MessageLifeCycleEvent, MessageLifeCycleExtensionStatusEvent, type MessagePayloadTypes, type MessageSources, Metadata, type MetadataStringValue, type MetadataTypedValue, type MissingRemoteClientError, type NetworkConfig, NumberOfValues, type Offer, OfferIO, OneTimeDataRequestBuilder, type OneTimeDataRequestBuilderItem, OpenPopupExtensionInteraction, type OptionalRadixDappToolkitOptions, Persona, PersonaDataName, PersonaDataNameVariant, PersonaDataRequestItem, PersonaDataRequestResponseItem, Proof, type Providers, RadixConnectRelayModule, RadixDappToolkit, type RadixDappToolkitOptions, RadixNetwork, RadixNetworkConfig, RadixNetworkConfigById, RdtState, type RemoteClientDisconnected, type RemoteClientIsAlreadyConnected, type RemoteClientJustConnected, type RemoteData, RequestItemModule, type RequestItemModuleInput, ResetRequestItem, type SendTransactionInput, SendTransactionItem, SendTransactionResponseItem, type SendTransactionResult, type Session, SessionModule, SharedData, type SignalingServerErrorResponse, SignalingServerMessage, type SignalingServerResponse, SignedChallenge, SignedChallengeAccount, SignedChallengePersona, Sources, StateModule, StatusExtensionInteraction, type StorageChange, type StorageModule, TransactionStatus, type TransactionStatusResponse, TransformRdtDataRequestToWalletRequestInput, type TransportProvider, type ValidationError, type WalletApi, WalletAuthorizedRequestItems, WalletAuthorizedRequestResponseItems, WalletData, WalletDataPersonaData, WalletDataPersonaDataEmailAddresses, WalletDataPersonaDataFullName, WalletDataPersonaDataPhoneNumbersAddresses, type WalletDataRequest, type WalletDataRequestError, type WalletDataRequestResponse, type WalletDataRequestResult, type WalletDataState, type WalletDataStateAccount, type WalletDataStatePersonaData, WalletInteraction, WalletInteractionExtensionInteraction, WalletInteractionFailureResponse, WalletInteractionItems, WalletInteractionResponse, WalletInteractionResponseItems, WalletInteractionSuccessResponse, type WalletRequest, WalletRequestItems, WalletRequestModule, WalletRequestResponseItems, WalletRequestSdk, type WalletRequestSdkInput, WalletTransactionItems, WalletTransactionResponseItems, WalletUnauthorizedRequestItems, WalletUnauthorizedRequestResponseItems, blake2b, canDataRequestBeResolvedByRdtState, config, eventType, extensionInteractionDiscriminator, fetchWrapper, generateGatewayApiConfig, generateRolaChallenge, isMobile, messageLifeCycleEventType, parseJSON, parseSignedChallenge, personaDataFullNameVariant, proofType, removeUndefined, stringify, toWalletRequest, transformRdtDataRequestToWalletRequest, transformSharedDataToDataRequestState, transformWalletDataToConnectButton, transformWalletRequestToSharedData, transformWalletResponseToRdtWalletData, typedError, unwrapObservable, validateRolaChallenge, validateWalletResponse, walletDataDefault };
